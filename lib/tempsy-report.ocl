import 'platform:/resource/lu.svv.offline/models/tempsy.ecore#/'
import 'platform:/resource/lu.svv.offline/models/trace.ecore#/'
import 'platform:/resource/lu.svv.offline/models/check.ecore#/'

package check

context Monitor

--------------------  Scopes  ----------------------

def: ordinalIndexOf(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer):Integer =
let result:Tuple(index:Integer, count:Integer) = trace->iterate(elem:trace::TraceElement;
  iter:Tuple(index:Integer, count:Integer) = Tuple{index:Integer = 0, count:Integer = 0}
  |
  if iter.count = n then
    iter
  else
    if elem.event = eventName then
      Tuple{index:Integer = iter.index + 1, count:Integer = iter.count + 1}
    else
      Tuple{index:Integer = iter.index + 1, count:Integer = iter.count}
    endif
  endif
)
in
if result.count = n then
  result.index
else
  -1
endif

def:indexOfAtLeastBefore(trace:OrderedSet(trace::TraceElement), position:Integer, timeDistance:Integer):Integer =
let toTimestamp:Integer = trace->at(position).timestamp in
trace->subOrderedSet(1, position)->iterate(elem:trace::TraceElement; iter:Tuple(index:Integer, flag:Boolean) = Tuple{index:Integer = 0, flag:Boolean = true} |
  if iter.flag then
    if toTimestamp - elem.timestamp < timeDistance then
      Tuple{index:Integer = iter.index, flag:Boolean = false}
    else
      Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag}
    endif
  else
    iter
  endif
).index

def:indexOfAtMostBefore(trace:OrderedSet(trace::TraceElement), position:Integer, timeDistance:Integer):Integer =
let toTimestamp:Integer = trace->at(position).timestamp in
trace->subOrderedSet(1, position)->iterate(elem:trace::TraceElement; iter:Tuple(index:Integer, flag:Boolean) = Tuple{index:Integer = 0, flag:Boolean = true} |
  if iter.flag then
    if toTimestamp - elem.timestamp <= timeDistance then
      Tuple{index:Integer = iter.index + 1, flag:Boolean = false}
    else
      Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag}
    endif
  else
    iter
  endif
).index

def: atLeastBefore(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer, timeDistance:Integer):Tuple(begin:Integer, end:Integer) =
--return the scope of 'before [n] eventName at least timeDistance tu'
let position:Integer = ordinalIndexOf(trace, eventName, n) in
if 1 <> position.abs() then
  if 1 = timeDistance then
    Tuple{begin:Integer = 1, end:Integer = position - 1}
  else
    if trace->at(position).timestamp - trace->first().timestamp < timeDistance then
      null
    else
      let indexEnd:Integer = self.indexOfAtLeastBefore(trace,  position, timeDistance) in
      Tuple{begin:Integer = 1, end:Integer = indexEnd}
    endif
  endif
else
  null
endif

def: atMostBefore(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer, timeDistance:Integer):Tuple(begin:Integer, end:Integer) =
--return the scope of 'before [n] eventName at most timeDistance tu'
let position:Integer = ordinalIndexOf(trace, eventName, n) in
if -1 <> position then
  if trace->at(position).timestamp - trace->at(position - 1).timestamp > timeDistance then
    null
  else
    let indexBegin:Integer = self.indexOfAtMostBefore(trace, position, timeDistance) in
    Tuple{begin:Integer = indexBegin, end:Integer = position - 1}
  endif
else
  null
endif

def: exactlyBefore(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer, timeDistance:Integer):Tuple(begin:Integer, end:Integer) =
--return the scope of 'before [n] eventName exactly timeDistance tu'
let position:Integer = ordinalIndexOf(trace, eventName, n) in
if -1 <> position then
  let index:Integer = self.indexOfAtMostBefore(trace, position, timeDistance) in
  if trace->at(position).timestamp - trace->at(index).timestamp = timeDistance then
    Tuple{begin:Integer = index, end:Integer = index}
  else
    null
  endif
else
  null
endif

def: applyScopeBefore(trace:trace::Trace, scope:tempsy::Scope):Tuple(begin:Integer, end:Integer) =
--return the scope of 'before boundary'
--'boundary' : '[n] eventName [comparingOperator timeDistance tu]'
let boundary:tempsy::Boundary = scope.oclAsType(tempsy::UniScope).boundary, eventName:String = boundary.event.name in
if boundary.timeDistance->notEmpty() then
  let comparingOperator:tempsy::ComparingOperator = boundary.timeDistance.comparingOperator, timeDistance:Integer = boundary.timeDistance.value in
  if boundary.ordinal > 0 then
    let n:Integer = boundary.ordinal in
    if tempsy::ComparingOperator::ATLEAST = comparingOperator then
      self.atLeastBefore(trace.traceElements, eventName,n,timeDistance) 
    else
      if tempsy::ComparingOperator::ATMOST = comparingOperator then
        self.atMostBefore(trace.traceElements, eventName,n,timeDistance)
      else
        self.exactlyBefore(trace.traceElements, eventName,n,timeDistance)
      endif
    endif
  else
    if tempsy::ComparingOperator::ATLEAST = comparingOperator then
      self.atLeastBefore(trace.traceElements, eventName,1,timeDistance)
    else
      if tempsy::ComparingOperator::ATMOST = comparingOperator then
        self.atMostBefore(trace.traceElements, eventName,1,timeDistance)
      else
        self.exactlyBefore(trace.traceElements, eventName,1,timeDistance)
      endif
    endif
  endif
else
  if boundary.ordinal > 0 then
    let n:Integer = boundary.ordinal in
    self.atLeastBefore(trace.traceElements, eventName,n,1)
  else
    self.atLeastBefore(trace.traceElements, eventName,1,1)
  endif
endif

def:indexOfAtLeastAfter(trace:OrderedSet(trace::TraceElement), position:Integer, timeDistance:Integer):Integer =
let fromTimestamp:Integer = trace->at(position).timestamp in
trace->subOrderedSet(position, trace->size())->iterate(elem:trace::TraceElement; iter:Tuple(index:Integer, flag:Boolean) = Tuple{index:Integer = position - 1, flag:Boolean = true} |
  if iter.flag then
    if elem.timestamp - fromTimestamp >= timeDistance then
      Tuple{index:Integer = iter.index + 1, flag:Boolean = false}
    else
      Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag}
    endif
  else
    iter
  endif
).index

def:indexOfAtMostAfter(trace:OrderedSet(trace::TraceElement), position:Integer, timeDistance:Integer):Integer =
let fromTimestamp:Integer = trace->at(position).timestamp in
trace->subOrderedSet(position, trace->size())->iterate(elem:trace::TraceElement; iter:Tuple(index:Integer, flag:Boolean) = Tuple{index:Integer = position - 1, flag:Boolean = true} |
  if iter.flag then
    if elem.timestamp - fromTimestamp > timeDistance then
      Tuple{index:Integer = iter.index, flag:Boolean = false}
    else
      Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag}
    endif
  else
    iter
  endif
).index

def: atLeastAfter(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer, timeDistance:Integer):Tuple(begin:Integer, end:Integer) =
--return the scope of 'after [n] eventName at least timeDistance tu'
let position:Integer = ordinalIndexOf(trace, eventName, n), size:Integer = trace->size() in
if -1 <> position and size <> position then
  if 1 = timeDistance then
    Tuple{begin:Integer = position + 1, end:Integer = size}
  else
    if trace->last().timestamp - trace->at(position).timestamp < timeDistance then
      null
    else
      let indexBegin:Integer = indexOfAtLeastAfter(trace, position, timeDistance) in
      Tuple{begin:Integer = indexBegin, end:Integer = size}
    endif
  endif
else
  null
endif

def: atMostAfter(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer, timeDistance:Integer):Tuple(begin:Integer, end:Integer) =
--return the scope of 'after [n] eventName at most timeDistance tu'
let position:Integer = ordinalIndexOf(trace, eventName, n) in
if -1 <> position and trace->size() <> position then
  if trace->at(position + 1).timestamp - trace->at(position).timestamp > timeDistance then
    null
  else
    let indexEnd:Integer = self.indexOfAtMostAfter(trace, position, timeDistance) in
    Tuple{begin:Integer = position + 1, end:Integer = indexEnd}
  endif
else
  null
endif

def: exactlyAfter(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer, timeDistance:Integer):Tuple(begin:Integer, end:Integer) =
--return the scope of 'after [n] eventName exactly timeDistance tu'
let position:Integer = ordinalIndexOf(trace, eventName, n) in
if -1 <> position then
  let index:Integer = indexOfAtMostAfter(trace, position, timeDistance) in
  if trace->at(index).timestamp - trace->at(position).timestamp = timeDistance then
    Tuple{begin:Integer = index, end:Integer = index}
  else
    null
  endif
else
  null
endif

def: applyScopeAfter(trace:trace::Trace, scope:tempsy::Scope):Tuple(begin:Integer, end:Integer) =
--return the scope of 'after boundary'
--'boundary' : '[n] eventName [comparingOperator timeDistance tu]'
let boundary:tempsy::Boundary = scope.oclAsType(tempsy::UniScope).boundary, eventName:String = boundary.event.name in
if boundary.timeDistance->notEmpty() then
  let comparingOperator:tempsy::ComparingOperator = boundary.timeDistance.comparingOperator, timeDistance:Integer = boundary.timeDistance.value in
  if boundary.ordinal > 0 then
      let n:Integer = boundary.ordinal in
    if tempsy::ComparingOperator::ATLEAST = comparingOperator then
      self.atLeastAfter(trace.traceElements, eventName, n, timeDistance)
    else if tempsy::ComparingOperator::ATMOST = comparingOperator then
        self.atMostAfter(trace.traceElements, eventName,n,timeDistance)
      else 
        self.exactlyAfter(trace.traceElements, eventName, n, timeDistance)
      endif 
    endif
  else
    if tempsy::ComparingOperator::ATLEAST = comparingOperator then
      self.atLeastAfter(trace.traceElements, eventName, 1,timeDistance)
    else if tempsy::ComparingOperator::ATMOST = comparingOperator then
        self.atMostAfter(trace.traceElements, eventName, 1, timeDistance)
      else 
        self.exactlyAfter(trace.traceElements, eventName, 1, timeDistance)
      endif 
    endif     
  endif
else
  if boundary.ordinal > 0 then
    let n:Integer = boundary.ordinal in
    self.atLeastAfter(trace.traceElements, eventName, n, 1)         
  else  
    self.atLeastAfter(trace.traceElements, eventName, 1, 1)
  endif
endif

--between at least n1 tu a and b
def:indexOfBetweenAndBegin(trace:OrderedSet(trace::TraceElement), posBegin:Integer, timestampBegin:Integer, posEnd:Integer):Integer =
trace->subOrderedSet(posBegin, posEnd)->iterate(elem:trace::TraceElement; iter:Tuple(index:Integer, flag:Boolean) = Tuple{index:Integer = posBegin - 1, flag:Boolean = true} |
  if iter.flag then
    if elem.timestamp >= timestampBegin then
      Tuple{index:Integer = iter.index + 1, flag:Boolean = false}
    else
      Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag}
    endif
  else
    iter
  endif
).index

--between a and at least n2 tu b
def:indexOfBetweenAndEnd(trace:OrderedSet(trace::TraceElement), posBegin:Integer, posEnd:Integer, timestampEnd:Integer):Integer =
trace->subOrderedSet(posBegin, posEnd)->iterate(elem:trace::TraceElement; iter:Tuple(index:Integer, flag:Boolean) = Tuple{index:Integer = posBegin - 1, flag:Boolean = true} |
  if iter.flag then
    if elem.timestamp > timestampEnd then
      Tuple{index:Integer = iter.index, flag:Boolean = false}
    else
      Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag}
    endif
  else
    iter
  endif
).index

--between at least n1 [m1] tu a and at least n2 tu [m2] b
def:indexOfBetweenAnd(trace:OrderedSet(trace::TraceElement), posBegin:Integer, timestampBegin:Integer, posEnd:Integer, timestampEnd:Integer):Tuple(begin:Integer, end:Integer) =
let tup:Tuple(indexBegin:Integer, indexEnd:Integer, flagBegin:Boolean, flagEnd:Boolean) =
  trace->subOrderedSet(posBegin, posEnd)->iterate(elem:trace::TraceElement; iter:Tuple(indexBegin:Integer, indexEnd:Integer, flagBegin:Boolean, flagEnd:Boolean) = Tuple{indexBegin:Integer = 0, indexEnd:Integer = 0, flagBegin:Boolean = true, flagEnd:Boolean = true} |
    if iter.flagBegin then
      let currentIndex:Integer = iter.indexBegin + 1 in
      if elem.timestamp >= timestampBegin then
        Tuple{indexBegin:Integer = currentIndex, indexEnd:Integer = currentIndex, flagBegin:Boolean = false, flagEnd:Boolean = iter.flagEnd}
      else
        Tuple{indexBegin:Integer = currentIndex, indexEnd:Integer = iter.indexEnd, flagBegin:Boolean = iter.flagBegin, flagEnd:Boolean = iter.flagEnd}
      endif
    else
      if iter.flagEnd then
        if elem.timestamp > timestampEnd then
          Tuple{indexBegin:Integer = iter.indexBegin, indexEnd:Integer = iter.indexEnd, flagBegin:Boolean = iter.flagBegin, flagEnd:Boolean = false}
        else
          Tuple{indexBegin:Integer = iter.indexBegin, indexEnd:Integer = iter.indexEnd + 1, flagBegin:Boolean = iter.flagBegin, flagEnd:Boolean = iter.flagEnd}
        endif
      else
        iter
      endif
    endif
  )
in
if tup.indexBegin <= tup.indexEnd then
  Tuple{begin:Integer = tup.indexBegin, end:Integer = tup.indexEnd}
else
  null
endif

def: applySpecialBetweenAnd(trace:OrderedSet(trace::TraceElement), eventNameBegin:String, nBegin:Integer, timeDistanceBegin:Integer, eventNameEnd:String, nEnd:Integer, timeDistanceEnd:Integer):Tuple(begin:Integer, end:Integer) =
--return the scope of 'between nBegin eventNameBegin at least timeDistanceBegin tu and nBegin eventNameEnd at least timeDistanceEnd tu'
let tup:Tuple(index:Integer, indexBegin:Integer, indexEnd:Integer, count:Integer) = trace->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, indexBegin:Integer, indexEnd:Integer, count:Integer) = Tuple{index:Integer = 0, indexBegin:Integer = 0, indexEnd:Integer = 0, count:Integer = 0} |
    if iter.indexBegin = 0 then
      let currentIndex:Integer = iter.index + 1 in
      if elem.event = eventNameBegin then
        let currentBeginCount:Integer = iter.count+1 in
        if currentBeginCount = nBegin then
          Tuple{index:Integer = currentIndex, indexBegin:Integer = currentIndex + 1, indexEnd:Integer = iter.indexEnd, count:Integer = 0}
        else
          Tuple{index:Integer = currentIndex, indexBegin:Integer = iter.indexBegin, indexEnd:Integer = iter.indexEnd, count:Integer = currentBeginCount}
        endif
      else
        Tuple{index:Integer = currentIndex, indexBegin:Integer = iter.indexBegin, indexEnd:Integer = iter.indexEnd, count:Integer = iter.count}
      endif
    else
      if iter.indexEnd = 0 then
        let currentIndex:Integer = iter.index + 1 in
        if elem.event = eventNameEnd then
          let currentEndCount:Integer = iter.count+1 in
          if currentEndCount = nEnd then
            Tuple{index:Integer = currentIndex, indexBegin:Integer = iter.indexBegin, indexEnd:Integer = currentIndex-1, count:Integer = nEnd}  
          else
            Tuple{index:Integer = currentIndex, indexBegin:Integer = iter.indexBegin, indexEnd:Integer = iter.indexEnd, count:Integer = currentEndCount}
          endif
        else
          Tuple{index:Integer = currentIndex, indexBegin:Integer = iter.indexBegin, indexEnd:Integer = iter.indexEnd, count:Integer = iter.count}
        endif
      else
        iter
      endif
    endif
  )
in
let
  i:Integer = tup.indexBegin,
  j:Integer = tup.indexEnd,
  timestampBegin:Integer = trace->at(i-1).timestamp+timeDistanceBegin,
  timestampEnd:Integer = trace->at(j+1).timestamp-timeDistanceEnd
in
if i > 0 and j > 0 and i <= j and timestampBegin <= timestampEnd then
  if timeDistanceBegin = 1 then
    if timeDistanceEnd = 1 then
      Tuple{begin:Integer = i, end:Integer = j}
    else
      let realIndexEnd:Integer = self.indexOfBetweenAndEnd(trace, i, j, timestampEnd) in
      if i <= realIndexEnd then
        Tuple{begin:Integer = i, end:Integer = realIndexEnd}
      else
        null
      endif
    endif
  else
    if timeDistanceEnd = 1 then
      let realIndexBegin:Integer = self.indexOfBetweenAndBegin(trace, i, timestampBegin, j) in
      if realIndexBegin <= j then
        Tuple{begin:Integer = realIndexBegin, end:Integer = j}
      else
        null
      endif
    else
      self.indexOfBetweenAnd(trace, i, j, timestampBegin, timestampEnd)
    endif
  endif
else
  null
endif

def: applyOriginalBetweenAnd(trace:OrderedSet(trace::TraceElement), eventNameBegin:String, eventNameEnd:String):Sequence(Tuple(begin:Integer, end:Integer)) =
--return the scope of 'between eventNameBegin and eventNameEnd'
trace->iterate(elem:trace::TraceElement;
  iter:Tuple(index:Integer, result:Sequence(Tuple(begin:Integer, end:Integer)), i:Integer)
  =Tuple{index:Integer = 0, result:Sequence(Tuple(begin:Integer, end:Integer)) = Sequence{}, i:Integer = 0} |
  if iter.i = 0 then
    let currentIndex:Integer = iter.index + 1 in
    if elem.event = eventNameBegin then
      Tuple{index:Integer = currentIndex, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result, i:Integer = currentIndex}
    else
      Tuple{index:Integer = currentIndex, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result, i:Integer = iter.i}
    endif
  else
    if elem.event = eventNameEnd then
      let i:Integer = iter.i+1, j:Integer = iter.index in
      if i <= j then
        Tuple{index:Integer = j + 1, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result->append(Tuple{begin:Integer = i, end:Integer = j}), i:Integer = 0}
      else
        Tuple{index:Integer = j + 1, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result, i:Integer = 0}
      endif
    else
      Tuple{index:Integer = iter.index + 1, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result, i:Integer = iter.i}
    endif
  endif
).result


def: applyOriginalBetweenAnd(trace:OrderedSet(trace::TraceElement), eventNameBegin:String, distanceBegin:Integer, eventNameEnd:String):Sequence(Tuple(begin:Integer, end:Integer)) =
--return the scope of 'between eventNameBegin at least distanceBegin tu and eventNameEnd'
trace->iterate(elem:trace::TraceElement;
  iter:Tuple(index:Integer, result:Sequence(Tuple(begin:Integer, end:Integer)), i:Integer, criticalTime:Integer)
  =Tuple{index:Integer = 0, result:Sequence(Tuple(begin:Integer, end:Integer)) = Sequence{}, i:Integer = 0, criticalTime:Integer = 0} |
  let e:String = elem.event in
  if iter.i = 0 then
    let currentIndex:Integer = iter.index + 1 in
    if e = eventNameBegin then
      Tuple{index:Integer = currentIndex, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result, i:Integer = currentIndex, criticalTime:Integer = elem.timestamp + distanceBegin}
    else
      Tuple{index:Integer = currentIndex, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result, i:Integer = iter.i, criticalTime:Integer = iter.criticalTime}
    endif
  else
    if e = eventNameEnd then
      let t:Integer = elem.timestamp, i:Integer = iter.i + 1, j:Integer = iter.index, t1:Integer = iter.criticalTime in
      if i <= j and t1 < t then
        let indexBegin:Integer = self.indexOfBetweenAndBegin(trace, i, t1, j) in
        if indexBegin <= j then
          Tuple{index:Integer = j + 1, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result->append(Tuple{begin:Integer = indexBegin, end:Integer = j}), i:Integer = 0, criticalTime:Integer = iter.criticalTime}
        else
          Tuple{index:Integer = j + 1, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result, i:Integer = 0, criticalTime:Integer = iter.criticalTime}
        endif  
      else
        Tuple{index:Integer = j + 1, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result, i:Integer = 0, criticalTime:Integer = iter.criticalTime}
      endif
    else
      Tuple{index:Integer = iter.index + 1, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result, i:Integer = iter.i, criticalTime:Integer = iter.criticalTime}
    endif
  endif
).result

def: applyOriginalBetweenAnd(trace:OrderedSet(trace::TraceElement), eventNameBegin:String, eventNameEnd:String, distanceEnd:Integer):Sequence(Tuple(begin:Integer, end:Integer)) =
--return the scope of 'between eventNameBegin and at least distanceEnd tu eventNameEnd'
trace->iterate(elem:trace::TraceElement;
  iter:Tuple(index:Integer, result:Sequence(Tuple(begin:Integer, end:Integer)), i:Integer, criticalTime:Integer)
  =Tuple{index:Integer = 0, result:Sequence(Tuple(begin:Integer, end:Integer)) = Sequence{}, i:Integer = 0, criticalTime:Integer = 0} |
  let e:String = elem.event in
  if iter.i = 0 then
    let currentIndex:Integer = iter.index + 1 in
    if e = eventNameBegin then
      Tuple{index:Integer = currentIndex, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result, i:Integer = currentIndex, criticalTime:Integer = elem.timestamp + 1}
    else
      Tuple{index:Integer = currentIndex, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result, i:Integer = iter.i, criticalTime:Integer = iter.criticalTime}
    endif
  else
    if e = eventNameEnd then
      let t:Integer = elem.timestamp, i:Integer = iter.i + 1, j:Integer = iter.index, t1:Integer = iter.criticalTime, t2:Integer = t - distanceEnd in
      if i <= j and t1 <= t2 then
        let indexEnd:Integer = self.indexOfBetweenAndEnd(trace, i, j, t2) in
        if i <= indexEnd then
          Tuple{index:Integer = j + 1, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result->append(Tuple{begin:Integer = i, end:Integer = indexEnd}), i:Integer = 0, criticalTime:Integer = iter.criticalTime}
        else
          Tuple{index:Integer = j + 1, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result, i:Integer = 0, criticalTime:Integer = iter.criticalTime}
        endif
      else
        Tuple{index:Integer = j + 1, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result, i:Integer = 0, criticalTime:Integer = iter.criticalTime}
      endif
    else
      Tuple{index:Integer = iter.index + 1, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result, i:Integer = iter.i, criticalTime:Integer = iter.criticalTime}
    endif
  endif
).result

def: applyOriginalBetweenAnd(trace:OrderedSet(trace::TraceElement), eventNameBegin:String, distanceBegin:Integer, eventNameEnd:String, distanceEnd:Integer):Sequence(Tuple(begin:Integer, end:Integer)) =
--return the scope of 'between eventNameBegin at least distanceBegin tu and at least distanceEnd tu eventNameEnd'
trace->iterate(elem:trace::TraceElement;
  iter:Tuple(index:Integer, result:Sequence(Tuple(begin:Integer, end:Integer)), i:Integer, criticalTime:Integer)
  =Tuple{index:Integer = 0, result:Sequence(Tuple(begin:Integer, end:Integer)) = Sequence{}, i:Integer = 0, criticalTime:Integer = 0} |
  let e:String = elem.event in
  if iter.i = 0 then
    let currentIndex:Integer = iter.index + 1 in
    if e = eventNameBegin then
      Tuple{index:Integer = currentIndex, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result, i:Integer = currentIndex, criticalTime:Integer = elem.timestamp + distanceBegin}
    else
      Tuple{index:Integer = currentIndex, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result, i:Integer = iter.i, criticalTime:Integer = iter.criticalTime}
    endif
  else
    if e = eventNameEnd then
      let t:Integer = elem.timestamp, i:Integer = iter.i + 1, j:Integer = iter.index, t1:Integer = iter.criticalTime, t2:Integer = t - distanceEnd in
      if i <= j and t1 <= t2 then
        let seg:Tuple(begin:Integer, end:Integer) = self.indexOfBetweenAnd(trace, i, t1, j, t2) in
        if seg <> null then
          Tuple{index:Integer = j + 1, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result->append(seg), i:Integer = 0, criticalTime:Integer = iter.criticalTime}
        else
          Tuple{index:Integer = j + 1, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result, i:Integer = 0, criticalTime:Integer = iter.criticalTime}
        endif
      else
        Tuple{index:Integer = j + 1, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result, i:Integer = 0, criticalTime:Integer = iter.criticalTime}
      endif
    else
      Tuple{index:Integer = iter.index + 1, result:Sequence(Tuple(begin:Integer, end:Integer)) = iter.result, i:Integer = iter.i, criticalTime:Integer = iter.criticalTime}
    endif
  endif
).result

def: applyScopeBetweenAnd(trace:trace::Trace, scope:tempsy::Scope):Sequence(Tuple(begin:Integer, end:Integer)) = 
--return the scope of 'between boundaryBegin and boundaryEnd'
--i.e., 'between [nBegin] eventNameBegin [at least timeDistanceBegin] and [nEnd] eventNameEnd [at least timeDistanceEnd]'
let boundaryBegin:tempsy::Boundary = scope.oclAsType(tempsy::BiScope).boundaryBegin,
  boundaryEnd:tempsy::Boundary = scope.oclAsType(tempsy::BiScope).boundaryEnd,
  eventNameBegin:String = boundaryBegin.event.name,
  eventNameEnd:String = boundaryEnd.event.name
in
if boundaryBegin.timeDistance->notEmpty() then
  let timeDistanceBegin:Integer = boundaryBegin.timeDistance.value in 
  if boundaryEnd.timeDistance->notEmpty() then
    let timeDistanceEnd:Integer = boundaryEnd.timeDistance.value in
    if boundaryBegin.ordinal > 0 then
      let result:Sequence(Tuple(begin:Integer, end:Integer)) = Sequence{}, nBegin:Integer = boundaryBegin.ordinal in
      if boundaryEnd.ordinal > 0 then
        let nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, timeDistanceBegin, eventNameEnd, nEnd, timeDistanceEnd))
      else
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, timeDistanceBegin, eventNameEnd, 1, timeDistanceEnd))
      endif
    else
      if boundaryEnd.ordinal > 0 then
        let result:Sequence(Tuple(begin:Integer, end:Integer)) = Sequence{}, nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, 1, timeDistanceBegin, eventNameEnd, nEnd, timeDistanceEnd))
      else
        self.applyOriginalBetweenAnd(trace.traceElements, eventNameBegin, timeDistanceBegin, eventNameEnd, timeDistanceEnd)
      endif
    endif
  else
    if boundaryBegin.ordinal > 0 then
      let result:Sequence(Tuple(begin:Integer, end:Integer)) = Sequence{}, nBegin:Integer = boundaryBegin.ordinal in
      if boundaryEnd.ordinal > 0 then
        let nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, timeDistanceBegin, eventNameEnd, nEnd, 1))
      else
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, timeDistanceBegin, eventNameEnd, 1, 1))
      endif
    else
      if boundaryEnd.ordinal > 0 then
        let result:Sequence(Tuple(begin:Integer, end:Integer)) = Sequence{}, nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, 1, timeDistanceBegin, eventNameEnd, nEnd, 1))
      else
        self.applyOriginalBetweenAnd(trace.traceElements, eventNameBegin, timeDistanceBegin, eventNameEnd)
      endif
    endif
  endif
else
  if boundaryEnd.timeDistance->notEmpty() then
    let timeDistanceEnd:Integer = boundaryEnd.timeDistance.value in
    if boundaryBegin.ordinal > 0 then
      let result:Sequence(Tuple(begin:Integer, end:Integer)) = Sequence{}, nBegin:Integer = boundaryBegin.ordinal in
      if boundaryEnd.ordinal > 0 then
        let nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, 1, eventNameEnd, nEnd, timeDistanceEnd))
      else
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, 1, eventNameEnd, 1, timeDistanceEnd))
      endif
    else
      if boundaryEnd.ordinal > 0 then
        let result:Sequence(Tuple(begin:Integer, end:Integer)) = Sequence{}, nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, 1, 1, eventNameEnd, nEnd, timeDistanceEnd))
      else
        self.applyOriginalBetweenAnd(trace.traceElements, eventNameBegin, eventNameEnd, timeDistanceEnd)
      endif
    endif
  else
    if boundaryBegin.ordinal > 0 then
      let result:Sequence(Tuple(begin:Integer, end:Integer)) = Sequence{}, nBegin:Integer = boundaryBegin.ordinal in
      if boundaryEnd.ordinal > 0 then
        let nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, 1, eventNameEnd, nEnd, 1))
      else
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, 1, eventNameEnd, 1, 1))
      endif
    else
      if boundaryEnd.ordinal > 0 then
        let result:Sequence(Tuple(begin:Integer, end:Integer)) = Sequence{}, nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, 1, 1, eventNameEnd, nEnd, 1))
      else
        self.applyOriginalBetweenAnd(trace.traceElements, eventNameBegin, eventNameEnd)
      endif
    endif
  endif
endif

def: applyScopeGlobally(trace:trace::Trace, scope:tempsy::Scope):Tuple(begin:Integer, end:Integer) = 
Tuple{begin:Integer = 1, end:Integer = trace.traceElements->size()}

--------------------  Patterns  ----------------------

--NEW since 05/02/2015

def: compare(a:Integer, b:Integer, which:Integer):Boolean =
if which = 1 then --at least b tu
  a >= b
else
  if which = 2 then --at most b tu
    a <= b
  else
    if which = 3 then --exactly b tu
      a = b
    else
      true --no comparison is needed
    endif
  endif
endif

def: loadDistances(distances:Sequence(tempsy::TimeDistance)):Sequence(Tuple(which:Integer, value:Integer)) =
if distances->forAll(elem | elem->isEmpty()) then
  Sequence{}
else
  distances->iterate(elem:tempsy::TimeDistance; iter:Sequence(Tuple(which:Integer, value:Integer)) = Sequence{} |
    if elem->isEmpty() then
      iter->append(Tuple{which:Integer = 0, value:Integer = 1})
    else
      if tempsy::ComparingOperator::ATLEAST = elem.comparingOperator then
        iter->append(Tuple{which:Integer = 1, value:Integer = elem.value})
      else
        if tempsy::ComparingOperator::ATMOST = elem.comparingOperator then
          iter->append(Tuple{which:Integer = 2, value:Integer = elem.value})
        else
          iter->append(Tuple{which:Integer = 3, value:Integer = elem.value})
        endif
      endif
    endif
  )
endif

/******************************************
 * =reportPatternResponseOneOne
 ******************************************
*/

-- modified on 23/08/2015
def: reportPatternResponseOneOnePlain(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeLocations:Sequence(Integer) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, causeLocations:Sequence(Integer)) = Tuple{index:Integer = begin, causeLocations:Sequence(Integer) = Sequence{}}
    |
    let e:String = elem.event in
    if e = cause then
      Tuple{index:Integer = iter.index + 1, causeLocations:Sequence(Integer) = iter.causeLocations->append(iter.index)}
    else
      if e = effect then
        Tuple{index:Integer = iter.index + 1, causeLocations:Sequence(Integer) = Sequence{}}
      else
        Tuple{index:Integer = iter.index + 1, causeLocations:Sequence(Integer) = iter.causeLocations}
      endif
    endif
  ).causeLocations
in
if causeLocations->notEmpty() then
  Sequence{
    Tuple{
      causeLocations:Sequence(Integer) = causeLocations,
      effectLocations:Sequence(Integer) = Sequence{},
      violationType:ViolationType = ViolationType::NSOR
    }
  }
else
  null
endif

-- modified on 23/08/2015
def: reportPatternResponseOneOneAtLeastMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, distance:Integer, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  result:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), effectLocation:Integer) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), effectLocation:Integer)
    = Tuple{index:Integer = begin, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, effectLocation:Integer = 0}
    |
    let e:String = elem.event in
    if e = cause then
      Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + distance, causeLocation:Integer = iter.index}), effectLocation:Integer = iter.effectLocation}
    else
      if e = effect then
        Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > elem.timestamp), effectLocation:Integer = iter.index}
      else
        Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.candidates.causeLocation->first() < result.effectLocation then
    if result.candidates.causeLocation->last() < result.effectLocation then
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates.causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.effectLocation},
          violationType:ViolationType = ViolationType::WTO
        }
      }
    else
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.effectLocation).causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.effectLocation},
          violationType:ViolationType = ViolationType::WTO
        },
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.effectLocation).causeLocation,
          effectLocations:Sequence(Integer) = Sequence{},
          violationType:ViolationType = ViolationType::NSOR
        }
      }
    endif
  else
    Sequence{
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    }
  endif
else
  null
endif

-- modified on 24/08/2015
def: reportPatternResponseOneOneAtMostMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, distance:Integer, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  result:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if e = cause then
      Tuple{
        index:Integer = iter.index + 1,
        candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + distance, causeLocation:Integer = iter.index}),
        violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
      }
    else
      if e = effect then
        if iter.candidates->exists(midCriticalInstant < elem.timestamp) then
          Tuple{
            index:Integer = iter.index + 1,
            candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{},
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = iter.candidates->select(midCriticalInstant < elem.timestamp).causeLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
          }
        else
          Tuple{
            index:Integer = iter.index + 1,
            candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{},
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        endif
      else
        Tuple{
          index:Integer = iter.index + 1,
          candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
          violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
        }
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  result.violations->append(
    Tuple{
      causeLocations:Sequence(Integer) = result.candidates.causeLocation,
      effectLocations:Sequence(Integer) = Sequence{},
      violationType:ViolationType = ViolationType::NSOR
    }
  )
else
  result.violations
endif

-- modified on 24/08/2015
def: reportPatternResponseOneOneExactlyMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, distance:Integer, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  result:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), lastEffectLocation:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), lastEffectLocation:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, lastEffectLocation:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if e = cause then
      Tuple{
        index:Integer = iter.index + 1,
        candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + distance, causeLocation:Integer = iter.index}),
        lastEffectLocation:Integer = iter.lastEffectLocation,
        violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
      }
    else
      if e = effect then
        let causeLocations:Sequence(Integer) = iter.candidates->select(midCriticalInstant < elem.timestamp).causeLocation in
        if causeLocations->notEmpty() then
          if iter.lastEffectLocation < iter.candidates.causeLocation->first() then--collect the first right effect
            Tuple{
              index:Integer = iter.index + 1,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > elem.timestamp),
              lastEffectLocation:Integer = iter.index,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
            }
          else
            if iter.lastEffectLocation < causeLocations->last() then--separate into two violation collections
              Tuple{
                index:Integer = iter.index + 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > elem.timestamp),
                lastEffectLocation:Integer = iter.index,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}})
              }
            else--collect the effects on both sides of midCriticalInstant
              Tuple{
                index:Integer = iter.index + 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > elem.timestamp),
                lastEffectLocation:Integer = iter.index,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation, iter.index}, violationType:ViolationType = ViolationType::WTO})
              }
            endif
          endif
        else--keep record of last effect location
          Tuple{
            index:Integer = iter.index + 1,
            candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->reject(midCriticalInstant = elem.timestamp),
            lastEffectLocation:Integer = iter.index,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        endif
      else
        Tuple{
          index:Integer = iter.index + 1,
          candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
          lastEffectLocation:Integer = iter.index,
          violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
        }
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.candidates.causeLocation->first() < result.lastEffectLocation then
    if result.candidates.causeLocation->last() < result.lastEffectLocation then
      result.violations->append(
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates.causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
          violationType:ViolationType = ViolationType::WTO
        }
      )
    else
      result.violations->union(
        Sequence{
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.lastEffectLocation).causeLocation,
            effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
            violationType:ViolationType = ViolationType::WTO
          },
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.lastEffectLocation).causeLocation,
            effectLocations:Sequence(Integer) = Sequence{},
            violationType:ViolationType = ViolationType::NSOR
          }
        }
      )
    endif
  else
    result.violations->append(
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    )
  endif
else
  result.violations
endif

-- modified on 23/08/2015
def: reportPatternResponseOneOneMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, distance:tempsy::TimeDistance, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let value:Integer = distance.value, which:tempsy::ComparingOperator = distance.comparingOperator in
if which = tempsy::ComparingOperator::ATLEAST then
  self.reportPatternResponseOneOneAtLeastMid(trace, begin, end, cause, value, effect)
else
  if which = tempsy::ComparingOperator::ATMOST then
    self.reportPatternResponseOneOneAtMostMid(trace, begin, end, cause, value, effect)
  else
    self.reportPatternResponseOneOneExactlyMid(trace, begin, end, cause, value, effect)
  endif
endif

/******************************************
 * =reportPatternResponseManyOne
 ******************************************
*/

-- modified on 24/08/2015
def: reportPatternResponseManyOnePlain(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  result:Tuple(index:Integer, i1:Integer, causeLocations:Sequence(Integer)) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, causeLocations:Sequence(Integer))
    = Tuple{index:Integer = begin, i1:Integer = 1, causeLocations:Sequence(Integer) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i1 > 1 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeLocations:Sequence(Integer) = iter.causeLocations->append(iter.index)}
      else
        Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, causeLocations:Sequence(Integer) = iter.causeLocations}
      endif
    else
      if e = firstCause then
        Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeLocations:Sequence(Integer) = iter.causeLocations}
      else
        if e = effect then
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeLocations:Sequence(Integer) = Sequence{}}
        else
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeLocations:Sequence(Integer) = iter.causeLocations}
        endif
      endif
    endif
  )
in
if result.causeLocations->notEmpty() then
  Sequence{
    Tuple{
      causeLocations:Sequence(Integer) = result.causeLocations,
      effectLocations:Sequence(Integer) = Sequence{},
      violationType:ViolationType = ViolationType::NSOR
    }
  }
else
  null
endif

-- modified on 24/08/2015
def: reportPatternResponseManyOneAtLeastMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), distance:Integer, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  result:Tuple(index:Integer, i1:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), effectLocation:Integer) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), effectLocation:Integer)
    = Tuple{index:Integer = begin, i1:Integer = 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, effectLocation:Integer = 0}
    |
    let e:String = elem.event in
    if iter.i1 > 1 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{
          index:Integer = iter.index + 1,
          i1:Integer = 1,
          candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + distance, causeLocation:Integer = iter.index}),
          effectLocation:Integer = iter.effectLocation
        }
      else
        Tuple{
          index:Integer = iter.index + 1,
          i1:Integer = iter.i1 + 1,
          candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
          effectLocation:Integer = iter.effectLocation
        }
      endif
    else
      if e = firstCause then
        Tuple{
          index:Integer = iter.index + 1,
          i1:Integer = 2,
          candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
          effectLocation:Integer = iter.effectLocation
        }
      else
        if e = effect then
          Tuple{
            index:Integer = iter.index + 1,
            i1:Integer = 1,
            candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > elem.timestamp),
            effectLocation:Integer = iter.index
          }
        else
          Tuple{
            index:Integer = iter.index + 1,
            i1:Integer = 1,
            candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
            effectLocation:Integer = iter.effectLocation
          }
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.candidates.causeLocation->first() < result.effectLocation then
    if result.candidates.causeLocation->last() < result.effectLocation then
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates.causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.effectLocation},
          violationType:ViolationType = ViolationType::WTO
        }
      }
    else
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.effectLocation).causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.effectLocation},
          violationType:ViolationType = ViolationType::WTO
        },
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.effectLocation).causeLocation,
          effectLocations:Sequence(Integer) = Sequence{},
          violationType:ViolationType = ViolationType::NSOR
        }
      }
    endif
  else
    Sequence{
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    }
  endif
else
  null
endif

-- modified on 24/08/2015
def: reportPatternResponseManyOneAtMostMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), distance:Integer, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  result:Tuple(index:Integer, i1:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, i1:Integer = 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i1 > 1 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{
          index:Integer = iter.index + 1,
          i1:Integer = 1,
          candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + distance, causeLocation:Integer = iter.index}),
          violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
        }
      else
        Tuple{
          index:Integer = iter.index + 1,
          i1:Integer = iter.i1 + 1,
          candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
        }
      endif
    else
      if e = firstCause then
        Tuple{
          index:Integer = iter.index + 1,
          i1:Integer = 2,
          candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
        }
      else
        if e = effect then
          if iter.candidates->exists(midCriticalInstant < elem.timestamp) then
            Tuple{
              index:Integer = iter.index + 1,
              i1:Integer = 1,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{},
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = iter.candidates->select(midCriticalInstant < elem.timestamp).causeLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
            }
          else
            Tuple{
              index:Integer = iter.index + 1,
              i1:Integer = 1,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{},
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          endif
        else
          Tuple{
            index:Integer = iter.index + 1,
            i1:Integer = 1,
            candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  result.violations->append(
    Tuple{
      causeLocations:Sequence(Integer) = result.candidates.causeLocation,
      effectLocations:Sequence(Integer) = Sequence{},
      violationType:ViolationType = ViolationType::NSOR
    }
  )
else
  result.violations
endif

-- modified on 24/08/2015
def: reportPatternResponseManyOneExactlyMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), distance:Integer, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  result:Tuple(index:Integer, i1:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), lastEffectLocation:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), lastEffectLocation:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, i1:Integer = 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, lastEffectLocation:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i1 > 1 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{
          index:Integer = iter.index + 1,
          i1:Integer = 1,
          candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + distance, causeLocation:Integer = iter.index}),
          lastEffectLocation:Integer = iter.lastEffectLocation,
          violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
        }
      else
        Tuple{
          index:Integer = iter.index + 1,
          i1:Integer = iter.i1 + 1,
          candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
          lastEffectLocation:Integer = iter.lastEffectLocation,
          violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
        }
      endif
    else
      if e = firstCause then
        Tuple{
          index:Integer = iter.index + 1,
          i1:Integer = 2,
          candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
          lastEffectLocation:Integer = iter.lastEffectLocation,
          violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
        }
      else
        if e = effect then
          let causeLocations:Sequence(Integer) = iter.candidates->select(midCriticalInstant < elem.timestamp).causeLocation in
          if causeLocations->notEmpty() then
            if iter.lastEffectLocation < iter.candidates.causeLocation->first() then--collect the first right effect
              Tuple{
                index:Integer = iter.index + 1,
                i1:Integer = 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > elem.timestamp),
                lastEffectLocation:Integer = iter.index,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
              }
            else
              if iter.lastEffectLocation < causeLocations->last() then--separate into two violation collections
                Tuple{
                  index:Integer = iter.index + 1,
                  i1:Integer = 1,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > elem.timestamp),
                  lastEffectLocation:Integer = iter.index,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}})
                }
              else
                Tuple{
                  index:Integer = iter.index + 1,
                  i1:Integer = 1,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > elem.timestamp),
                  lastEffectLocation:Integer = iter.index,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation, iter.index}, violationType:ViolationType = ViolationType::WTO})
                }
              endif
            endif
          else
            Tuple{
              index:Integer = iter.index + 1,
              i1:Integer = 1,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->reject(midCriticalInstant = elem.timestamp),
              lastEffectLocation:Integer = iter.index,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          endif
        else
          Tuple{
            index:Integer = iter.index + 1,
            i1:Integer = 1,
            candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
            lastEffectLocation:Integer = iter.lastEffectLocation,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.candidates.causeLocation->first() < result.lastEffectLocation then
    if result.candidates.causeLocation->last() < result.lastEffectLocation then
      result.violations->append(
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates.causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
          violationType:ViolationType = ViolationType::WTO
        }
      )
    else
      result.violations->union(
        Sequence{
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.lastEffectLocation).causeLocation,
            effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
            violationType:ViolationType = ViolationType::WTO
          },
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.lastEffectLocation).causeLocation,
            effectLocations:Sequence(Integer) = Sequence{},
            violationType:ViolationType = ViolationType::NSOR
          }
        }
      )
    endif
  else
    result.violations->append(
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    )
  endif
else
  result.violations
endif

--modified on 24/08/2015
def: reportPatternResponseManyOneMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), distance:tempsy::TimeDistance, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let value:Integer = distance.value, which:tempsy::ComparingOperator = distance.comparingOperator in
if which = tempsy::ComparingOperator::ATLEAST then
  self.reportPatternResponseManyOneAtLeastMid(trace, begin, end, causes, value, effect)
else
  if which = tempsy::ComparingOperator::ATMOST then
    self.reportPatternResponseManyOneAtMostMid(trace, begin, end, causes, value, effect)
  else
    self.reportPatternResponseManyOneExactlyMid(trace, begin, end, causes, value, effect)
  endif
endif

/******************************************
 * =reportPatternResponseManyOneLeft
 ******************************************
*/

-- modified on 25/08/2015
def: reportPatternResponseManyOneLeft(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  result:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, causeLocations:Sequence(Integer)) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, causeLocations:Sequence(Integer)) = Tuple{index:Integer = begin, i1:Integer = 1, causeCriticalInstant:Integer = 0, causeLocations:Sequence(Integer) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, causeLocations:Sequence(Integer) = iter.causeLocations->append(iter.index)}
      else
        let i11:Integer = iter.i1 + 1 in
        Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, causeLocations:Sequence(Integer) = iter.causeLocations}
      endif
    else
      if e = firstCause then
        Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, causeLocations:Sequence(Integer) = iter.causeLocations}
      else
        if e = effect then
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, causeLocations:Sequence(Integer) = Sequence{}}
        else
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, causeLocations:Sequence(Integer) = iter.causeLocations}
        endif
      endif
    endif
  )
in
if result.causeLocations->notEmpty() then
  Sequence{
    Tuple{
      causeLocations:Sequence(Integer) = result.causeLocations,
      effectLocations:Sequence(Integer) = Sequence{},
      violationType:ViolationType = ViolationType::NSOR
    }
  }
else
  null
endif

-- modified on 25/08/2015
def: reportPatternResponseManyOneLeftAtLeastMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  result:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), effectLocation:Integer) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), effectLocation:Integer)
    = Tuple{index:Integer = begin, i1:Integer = 1, causeCriticalInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, effectLocation:Integer = 0}
    |
    let e:String = elem.event in
    if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index}), effectLocation:Integer = iter.effectLocation}
      else
        let i11:Integer = iter.i1 + 1 in
        Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
      endif
    else
      if e = firstCause then
        Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
      else
        if e = effect then
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > elem.timestamp), effectLocation:Integer = iter.index}
        else
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.candidates.causeLocation->first() < result.effectLocation then
    if result.candidates.causeLocation->last() < result.effectLocation then
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates.causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.effectLocation},
          violationType:ViolationType = ViolationType::WTO
        }
      }
    else
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.effectLocation).causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.effectLocation},
          violationType:ViolationType = ViolationType::WTO
        },
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.effectLocation).causeLocation,
          effectLocations:Sequence(Integer) = Sequence{},
          violationType:ViolationType = ViolationType::NSOR
        }
      }
    endif
  else
    Sequence{
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    }
  endif
else
  null
endif

-- modified on 25/08/2015
def: reportPatternResponseManyOneLeftAtMostMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  result:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, i1:Integer = 1, causeCriticalInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index}), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
      else
        let i11:Integer = iter.i1 + 1 in
        Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
      endif
    else
      if e = firstCause then
        Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
      else
        if e = effect then
          if iter.candidates->exists(midCriticalInstant < elem.timestamp) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = iter.candidates->select(midCriticalInstant < elem.timestamp).causeLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
          else
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          endif
        else
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  result.violations->append(
    Tuple{
      causeLocations:Sequence(Integer) = result.candidates.causeLocation,
      effectLocations:Sequence(Integer) = Sequence{},
      violationType:ViolationType = ViolationType::NSOR
    }
  )
else
  result.violations
endif

-- modified on 25/08/2015
def: reportPatternResponseManyOneLeftExactlyMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  result:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), lastEffectLocation:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), lastEffectLocation:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, i1:Integer = 1, causeCriticalInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, lastEffectLocation:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index}), lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
      else
        let i11:Integer = iter.i1 + 1 in
        Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
      endif
    else
      if e = firstCause then
        Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
      else
        if e = effect then
          let causeLocations:Sequence(Integer) = iter.candidates->select(midCriticalInstant < elem.timestamp).causeLocation in
          if causeLocations->notEmpty() then
            if iter.lastEffectLocation < iter.candidates.causeLocation->first() then--collect the first right effect
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > elem.timestamp), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
            else
              if iter.lastEffectLocation < causeLocations->last() then--separate into two violation collections
                Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > elem.timestamp), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}})}
              else
                Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > elem.timestamp), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation, iter.index}, violationType:ViolationType = ViolationType::WTO})}
              endif
            endif
          else
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->reject(midCriticalInstant = elem.timestamp), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          endif
        else
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.candidates.causeLocation->first() < result.lastEffectLocation then
    if result.candidates.causeLocation->last() < result.lastEffectLocation then
      result.violations->append(
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates.causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
          violationType:ViolationType = ViolationType::WTO
        }
      )
    else
      result.violations->union(
        Sequence{
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.lastEffectLocation).causeLocation,
            effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
            violationType:ViolationType = ViolationType::WTO
          },
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.lastEffectLocation).causeLocation,
            effectLocations:Sequence(Integer) = Sequence{},
            violationType:ViolationType = ViolationType::NSOR
          }
        }
      )
    endif
  else
    result.violations->append(
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    )
  endif
else
  result.violations
endif

-- modified on 24/08/2015
def: reportPatternResponseManyOneLeftMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:tempsy::TimeDistance, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let midValue:Integer = midDistance.value, midWhich:tempsy::ComparingOperator = midDistance.comparingOperator in
if midWhich = tempsy::ComparingOperator::ATLEAST then
  self.reportPatternResponseManyOneLeftAtLeastMid(trace, begin, end, causes, causeDistances, midValue, effect)
else
  if midWhich = tempsy::ComparingOperator::ATMOST then
    self.reportPatternResponseManyOneLeftAtMostMid(trace, begin, end, causes, causeDistances, midValue, effect)
  else
    self.reportPatternResponseManyOneLeftExactlyMid(trace, begin, end, causes, causeDistances, midValue, effect)
  endif
endif

/******************************************
 * =reportPatternResponseOneMany
 ******************************************
*/

-- modified on 24/08/2015
def: reportPatternResponseOneManyPlain(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  result:Tuple(index:Integer, i2:Integer, causeLocations:Sequence(Integer)) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i2:Integer, causeLocations:Sequence(Integer)) = Tuple{index:Integer = begin, i2:Integer = 1, causeLocations:Sequence(Integer) = Sequence{}}
    |
    let e:String = elem.event in
    if e = cause then
      Tuple{index:Integer = iter.index + 1, i2:Integer = 1, causeLocations:Sequence(Integer) = iter.causeLocations->append(iter.index)}
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          Tuple{index:Integer = iter.index + 1, i2:Integer = 1, causeLocations:Sequence(Integer) = Sequence{}}
        else
          Tuple{index:Integer = iter.index + 1, i2:Integer = iter.i2 + 1, causeLocations:Sequence(Integer) = iter.causeLocations}
        endif
      else
        if iter.causeLocations->notEmpty() and e = firstEffect then
          Tuple{index:Integer = iter.index + 1, i2:Integer = 2, causeLocations:Sequence(Integer) = iter.causeLocations}
        else
          Tuple{index:Integer = iter.index + 1, i2:Integer = 1, causeLocations:Sequence(Integer) = iter.causeLocations}
        endif
      endif
    endif
  )
in
if result.causeLocations->notEmpty() then
  Sequence{
    Tuple{
      causeLocations:Sequence(Integer) = result.causeLocations,
      effectLocations:Sequence(Integer) = Sequence{},
      violationType:ViolationType = ViolationType::NSOR
    }
  }
else
  null
endif

-- modified on 24/08/2015
def: reportPatternResponseOneManyAtLeastMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, distance:Integer, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, i2:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), effectLocation:Integer) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i2:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), effectLocation:Integer)
    = Tuple{index:Integer = begin, i2:Integer = 1, rollbackInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, effectLocation:Integer = 0}
    |
    let e:String = elem.event in
    if e = cause then
      Tuple{index:Integer = iter.index + 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + distance, causeLocation:Integer = iter.index}), effectLocation:Integer = iter.effectLocation}
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          Tuple{index:Integer = iter.index + 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), effectLocation:Integer = iter.index}
        else
          Tuple{index:Integer = iter.index + 1, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
        endif
      else
        if iter.candidates->notEmpty() and e = firstEffect then
          Tuple{index:Integer = iter.index + 1, i2:Integer = 2, rollbackInstant:Integer = elem.timestamp, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
        else
          Tuple{index:Integer = iter.index + 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.candidates.causeLocation->first() < result.effectLocation then
    if result.candidates.causeLocation->last() < result.effectLocation then
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates.causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.effectLocation},
          violationType:ViolationType = ViolationType::WTO
        }
      }
    else
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.effectLocation).causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.effectLocation},
          violationType:ViolationType = ViolationType::WTO
        },
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.effectLocation).causeLocation,
          effectLocations:Sequence(Integer) = Sequence{},
          violationType:ViolationType = ViolationType::NSOR
        }
      }
    endif
  else
    Sequence{
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    }
  endif
else
  null
endif

-- modified on 24/08/2015
def: reportPatternResponseOneManyAtMostMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, distance:Integer, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, i2:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i2:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, i2:Integer = 1, rollbackInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if e = cause then
      Tuple{
        index:Integer = iter.index + 1,
        i2:Integer = 1,
        rollbackInstant:Integer = iter.rollbackInstant,
        candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + distance, causeLocation:Integer = iter.index}),
        violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
      }
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          if iter.candidates->exists(midCriticalInstant < iter.rollbackInstant) then
            Tuple{
              index:Integer = iter.index + 1,
              i2:Integer = 1,
              rollbackInstant:Integer = iter.rollbackInstant,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{},
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = iter.candidates->select(midCriticalInstant < iter.rollbackInstant).causeLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
            }
          else
            Tuple{
              index:Integer = iter.index + 1,
              i2:Integer = 1,
              rollbackInstant:Integer = iter.rollbackInstant,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{},
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          endif
        else
          Tuple{
            index:Integer = iter.index + 1,
            i2:Integer = iter.i2 + 1,
            rollbackInstant:Integer = iter.rollbackInstant,
            candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        endif
      else
        if iter.candidates->notEmpty() and e = firstEffect then
          Tuple{
            index:Integer = iter.index + 1,
            i2:Integer = 2,
            rollbackInstant:Integer = elem.timestamp,
            candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        else
          Tuple{
            index:Integer = iter.index + 1,
            i2:Integer = 1,
            rollbackInstant:Integer = iter.rollbackInstant,
            candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  result.violations->append(
    Tuple{
      causeLocations:Sequence(Integer) = result.candidates.causeLocation,
      effectLocations:Sequence(Integer) = Sequence{},
      violationType:ViolationType = ViolationType::NSOR
    }
  )
else
  result.violations
endif

-- modified on 24/08/2015
def: reportPatternResponseOneManyExactlyMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, distance:Integer, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, i2:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), lastEffectLocation:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i2:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), lastEffectLocation:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, i2:Integer = 1, rollbackInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, lastEffectLocation:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if e = cause then
      Tuple{
        index:Integer = iter.index + 1,
        i2:Integer = 1,
        rollbackInstant:Integer = iter.rollbackInstant,
        candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + distance, causeLocation:Integer = iter.index}),
        lastEffectLocation:Integer = iter.lastEffectLocation,
        violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
      }
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          let causeLocations:Sequence(Integer) = iter.candidates->select(midCriticalInstant < iter.rollbackInstant).causeLocation in
          if causeLocations->notEmpty() then
            if iter.lastEffectLocation < iter.candidates.causeLocation->first() then
              Tuple{
                index:Integer = iter.index + 1,
                i2:Integer = 1,
                rollbackInstant:Integer = iter.rollbackInstant,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), 
                lastEffectLocation:Integer = iter.index,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = iter.candidates->select(midCriticalInstant < iter.rollbackInstant).causeLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
              }
            else
              if iter.lastEffectLocation < causeLocations->last() then--separate into two violation collections
                Tuple{
                  index:Integer = iter.index + 1,
                  i2:Integer = 1,
                  rollbackInstant:Integer = iter.rollbackInstant,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant),
                  lastEffectLocation:Integer = iter.index,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}})
                }
              else
                Tuple{
                  index:Integer = iter.index + 1,
                  i2:Integer = 1,
                  rollbackInstant:Integer = iter.rollbackInstant,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant),
                  lastEffectLocation:Integer = iter.index,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation, iter.index}, violationType:ViolationType = ViolationType::WTO})
                }
              endif
            endif
          else
            Tuple{
              index:Integer = iter.index + 1,
              i2:Integer = 1,
              rollbackInstant:Integer = iter.rollbackInstant,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->reject(midCriticalInstant = iter.rollbackInstant),
              lastEffectLocation:Integer = iter.index,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          endif
        else
          Tuple{
            index:Integer = iter.index + 1,
            i2:Integer = iter.i2 + 1, 
            rollbackInstant:Integer = iter.rollbackInstant, 
            candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
            lastEffectLocation:Integer = iter.lastEffectLocation,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        endif
      else
        if iter.candidates->notEmpty() and e = firstEffect then
          Tuple{
            index:Integer = iter.index + 1,
            i2:Integer = 2,
            rollbackInstant:Integer = elem.timestamp,
            candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
            lastEffectLocation:Integer = iter.lastEffectLocation,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        else
          Tuple{
            index:Integer = iter.index + 1,
            i2:Integer = 1,
            rollbackInstant:Integer = iter.rollbackInstant,
            candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
            lastEffectLocation:Integer = iter.lastEffectLocation,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.candidates.causeLocation->first() < result.lastEffectLocation then
    if result.candidates.causeLocation->last() < result.lastEffectLocation then
      result.violations->append(
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates.causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
          violationType:ViolationType = ViolationType::WTO
        }
      )
    else
      result.violations->union(
        Sequence{
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.lastEffectLocation).causeLocation,
            effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
            violationType:ViolationType = ViolationType::WTO
          },
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.lastEffectLocation).causeLocation,
            effectLocations:Sequence(Integer) = Sequence{},
            violationType:ViolationType = ViolationType::NSOR
          }
        }
      )
    endif
  else
    result.violations->append(
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    )
  endif
else
  result.violations
endif

--modified on 24/08/2015
def: reportPatternResponseOneManyMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, distance:tempsy::TimeDistance, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let value:Integer = distance.value, which:tempsy::ComparingOperator = distance.comparingOperator in
if which = tempsy::ComparingOperator::ATLEAST then
  self.reportPatternResponseOneManyAtLeastMid(trace, begin, end, cause, value, effects)
else
  if which = tempsy::ComparingOperator::ATMOST then
    self.reportPatternResponseOneManyAtMostMid(trace, begin, end, cause, value, effects)
  else
    self.reportPatternResponseOneManyExactlyMid(trace, begin, end, cause, value, effects)
  endif
endif

/******************************************
 * =reportPatternResponseOneManyRight
 ******************************************
*/

-- modified on 25/08/2015
def: reportPatternResponseOneManyRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  lastEffectDistanceType:Integer = effectDistances->last().which,
  result:Tuple(index:Integer, i2:Integer, effectCriticalInstant:Integer, causeLocations:Sequence(Integer), wtcEffectLocation:Integer, notWTC:Boolean) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i2:Integer, effectCriticalInstant:Integer, causeLocations:Sequence(Integer), wtcEffectLocation:Integer, notWTC:Boolean)
    = Tuple{index:Integer = begin, i2:Integer = 1, effectCriticalInstant:Integer = 0, causeLocations:Sequence(Integer) = Sequence{}, wtcEffectLocation:Integer = 0, notWTC:Boolean = true}
    |
    let e:String = elem.event in
    if e = cause then
      Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, causeLocations:Sequence(Integer) = iter.causeLocations->append(iter.index), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, lastEffectDistanceType) then
            Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, causeLocations:Sequence(Integer) = Sequence{}, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
          else--record wtcEffectLocation and reset notWTC
            Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
          endif
        else
          let i22:Integer = iter.i2 + 1 in
          if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            Tuple{index:Integer = iter.index + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
          else
            Tuple{index:Integer = iter.index + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
          endif
        endif
      else
        if iter.causeLocations->notEmpty() and e = firstEffect then
          Tuple{index:Integer = iter.index + 1, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = true}
        else
          Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
        endif
      endif
    endif
  )
in
if result.causeLocations->notEmpty() then
  if result.causeLocations->first() < result.wtcEffectLocation then
    if result.causeLocations->last() < result.wtcEffectLocation then
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = result.causeLocations,
          effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
          violationType:ViolationType = ViolationType::WTC
        }
      }
    else
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = result.causeLocations->select(causeLocation | causeLocation < result.wtcEffectLocation),
          effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
          violationType:ViolationType = ViolationType::WTC
        },
        Tuple{
          causeLocations:Sequence(Integer) = result.causeLocations->select(causeLocation | causeLocation > result.wtcEffectLocation),
          effectLocations:Sequence(Integer) = Sequence{},
          violationType:ViolationType = ViolationType::NSOR
        }
      }
    endif
  else
    Sequence{
      Tuple{
        causeLocations:Sequence(Integer) = result.causeLocations,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    }
  endif
else
  null
endif

-- modified on 25/08/2015
def: reportPatternResponseOneManyAtLeastMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  lastEffectDistanceType:Integer = effectDistances->last().which,
  result:Tuple(index:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), effectLocation:Integer, wtcEffectLocation:Integer, notWTC:Boolean) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), effectLocation:Integer, wtcEffectLocation:Integer, notWTC:Boolean)
    = Tuple{index:Integer = begin, i2:Integer = 1, effectCriticalInstant:Integer = 0, rollbackInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, effectLocation:Integer = 0, wtcEffectLocation:Integer = 0, notWTC:Boolean = true}
    |
    let e:String = elem.event in
    if e = cause then
      Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index}), effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, lastEffectDistanceType) then
            Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), effectLocation:Integer = iter.index, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
          else
            Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
          endif
        else
          let i22:Integer = iter.i2 + 1 in
          if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            Tuple{index:Integer = iter.index + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
          else
            Tuple{index:Integer = iter.index + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
          endif
        endif
      else
        if iter.candidates->notEmpty() and e = firstEffect then
          let t:Integer = elem.timestamp in
          Tuple{index:Integer = iter.index + 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = true}
        else
          Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.effectLocation < result.candidates.causeLocation->first() and result.wtcEffectLocation < result.candidates.causeLocation->first() then
    Sequence{
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    }
  else
    let wtoCauseLocations:Sequence(Integer) = result.candidates->select(midCriticalInstant > result.rollbackInstant).causeLocation in
    if result.effectLocation < result.wtcEffectLocation then--in this case, left WTO violations are ignored and WTC/WTOC violations are reported
      let wtcCauseLocations:Sequence(Integer) = result.candidates->select(midCriticalInstant <= result.rollbackInstant).causeLocation in
      let nsorCauseLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.wtcEffectLocation).causeLocation in
      if wtcCauseLocations->notEmpty() then
        if wtoCauseLocations->notEmpty() then
          if nsorCauseLocations->notEmpty() then
            Sequence{
              Tuple{
                causeLocations:Sequence(Integer) = wtcCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
                violationType:ViolationType = ViolationType::WTC
              },
              Tuple{
                causeLocations:Sequence(Integer) = wtoCauseLocations->select(causeLocation | causeLocation < result.wtcEffectLocation),
                effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
                violationType:ViolationType = ViolationType::WTOC
              },
              Tuple{
                causeLocations:Sequence(Integer) = nsorCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{},
                violationType:ViolationType = ViolationType::NSOR
              }
            }
          else
            Sequence{
              Tuple{
                causeLocations:Sequence(Integer) = wtcCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
                violationType:ViolationType = ViolationType::WTC
              },
              Tuple{
                causeLocations:Sequence(Integer) = wtoCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
                violationType:ViolationType = ViolationType::WTOC
              }
            }
          endif
        else
          if nsorCauseLocations->notEmpty() then
            Sequence{
              Tuple{
                causeLocations:Sequence(Integer) = wtcCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
                violationType:ViolationType = ViolationType::WTC
              },
              Tuple{
                causeLocations:Sequence(Integer) = nsorCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{},
                violationType:ViolationType = ViolationType::NSOR
              }
            }
          else
            Sequence{
              Tuple{
                causeLocations:Sequence(Integer) = wtcCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
                violationType:ViolationType = ViolationType::WTC
              }
            }
          endif
        endif
      else--wtoCauseLocations must be not empty
        if nsorCauseLocations->notEmpty() then
          Sequence{
            Tuple{
              causeLocations:Sequence(Integer) = wtoCauseLocations->select(causeLocation | causeLocation < result.wtcEffectLocation),
              effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
              violationType:ViolationType = ViolationType::WTOC
            },
            Tuple{
              causeLocations:Sequence(Integer) = nsorCauseLocations,
              effectLocations:Sequence(Integer) = Sequence{},
              violationType:ViolationType = ViolationType::NSOR
            }
          }
        else
          Sequence{
            Tuple{
              causeLocations:Sequence(Integer) = wtoCauseLocations,
              effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
              violationType:ViolationType = ViolationType::WTOC
            }
          }
        endif
      endif
    else
      let nsorCauseLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.effectLocation).causeLocation in
      if nsorCauseLocations->notEmpty() then
        Sequence{
          Tuple{
            causeLocations:Sequence(Integer) = wtoCauseLocations->select(causeLocation | causeLocation < result.effectLocation),
            effectLocations:Sequence(Integer) = Sequence{result.effectLocation},
            violationType:ViolationType = ViolationType::WTO
          },
          Tuple{
            causeLocations:Sequence(Integer) = nsorCauseLocations,
            effectLocations:Sequence(Integer) = Sequence{},
            violationType:ViolationType = ViolationType::NSOR
          }
        }
      else
        Sequence{
          Tuple{
            causeLocations:Sequence(Integer) = wtoCauseLocations,
            effectLocations:Sequence(Integer) = Sequence{result.effectLocation},
            violationType:ViolationType = ViolationType::WTO
          }
        }
      endif
    endif
  endif
else
  null
endif

-- modified on 26/08/2015
def: reportPatternResponseOneManyAtMostMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  lastEffectDistanceType:Integer = effectDistances->last().which,
  result:Tuple(index:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)), wtcEffectLocation:Integer, notWTC:Boolean) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(
      index:Integer,
      i2:Integer,
      effectCriticalInstant:Integer,
      rollbackInstant:Integer,
      candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)),
      violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)),
      wtcEffectLocation:Integer,
      notWTC:Boolean)
    = Tuple{index:Integer = begin, i2:Integer = 1, effectCriticalInstant:Integer = 0, rollbackInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}, wtcEffectLocation:Integer = 0, notWTC:Boolean = true}
    |
    let e:String = elem.event in
    if e = cause then
      Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index}), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          let causeLocations:Sequence(Integer) = iter.candidates->select(midCriticalInstant < iter.rollbackInstant).causeLocation in
          if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, lastEffectDistanceType) then
            if causeLocations->notEmpty() then
              if iter.wtcEffectLocation < iter.candidates.causeLocation->first() then
                Tuple{
                  index:Integer = iter.index + 1,
                  i2:Integer = 1,
                  effectCriticalInstant:Integer = iter.effectCriticalInstant,
                  rollbackInstant:Integer = iter.rollbackInstant,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{},
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(
                    Tuple{
                      causeLocations:Sequence(Integer) = causeLocations,
                      effectLocations:Sequence(Integer) = Sequence{iter.index},
                      violationType:ViolationType = ViolationType::WTO
                    }
                  ),
                  wtcEffectLocation:Integer = iter.wtcEffectLocation,
                  notWTC:Boolean = iter.notWTC
                }
              else
                if iter.wtcEffectLocation < causeLocations->last() then
                  Tuple{
                    index:Integer = iter.index + 1,
                    i2:Integer = 1,
                    effectCriticalInstant:Integer = iter.effectCriticalInstant,
                    rollbackInstant:Integer = iter.rollbackInstant,
                    candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{},
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(
                      Sequence{
                        Tuple{
                          causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.wtcEffectLocation),
                          effectLocations:Sequence(Integer) = Sequence{iter.wtcEffectLocation},
                          violationType:ViolationType = ViolationType::WTC
                        },
                        Tuple{
                          causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.wtcEffectLocation),
                          effectLocations:Sequence(Integer) = Sequence{iter.index},
                          violationType:ViolationType = ViolationType::WTO
                        }
                      }
                    ),
                    wtcEffectLocation:Integer = iter.wtcEffectLocation,
                    notWTC:Boolean = iter.notWTC
                  }
                else--ignore the effectLocation out of the distance
                  Tuple{
                    index:Integer = iter.index + 1,
                    i2:Integer = 1,
                    effectCriticalInstant:Integer = iter.effectCriticalInstant,
                    rollbackInstant:Integer = iter.rollbackInstant,
                    candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{},
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(
                      Tuple{
                        causeLocations:Sequence(Integer) = causeLocations,
                        effectLocations:Sequence(Integer) = Sequence{iter.wtcEffectLocation},
                        violationType:ViolationType = ViolationType::WTC
                      }
                    ),
                    wtcEffectLocation:Integer = iter.wtcEffectLocation,
                    notWTC:Boolean = iter.notWTC
                  }
                endif
              endif
            else
              Tuple{
                index:Integer = iter.index + 1,
                i2:Integer = 1,
                effectCriticalInstant:Integer = iter.effectCriticalInstant,
                rollbackInstant:Integer = iter.rollbackInstant,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{},
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations,
                wtcEffectLocation:Integer = iter.wtcEffectLocation,
                notWTC:Boolean = iter.notWTC
              }
            endif
          else
            if causeLocations->notEmpty() then
              if iter.wtcEffectLocation < iter.candidates.causeLocation->first() then
                Tuple{
                  index:Integer = iter.index + 1,
                  i2:Integer = 1,
                  effectCriticalInstant:Integer = iter.effectCriticalInstant,
                  rollbackInstant:Integer = iter.rollbackInstant,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant),
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(
                    Tuple{
                      causeLocations:Sequence(Integer) = causeLocations,
                      effectLocations:Sequence(Integer) = Sequence{iter.index},
                      violationType:ViolationType = ViolationType::WTOC
                    }
                  ),
                  wtcEffectLocation:Integer = iter.index,
                  notWTC:Boolean = iter.notWTC
                }
              else
                if iter.wtcEffectLocation < causeLocations->last() then
                  Tuple{
                    index:Integer = iter.index + 1,
                    i2:Integer = 1,
                    effectCriticalInstant:Integer = iter.effectCriticalInstant,
                    rollbackInstant:Integer = iter.rollbackInstant,
                    candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant),
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(
                      Sequence{
                        Tuple{
                          causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.wtcEffectLocation),
                          effectLocations:Sequence(Integer) = Sequence{iter.wtcEffectLocation},
                          violationType:ViolationType = ViolationType::WTC
                        },
                        Tuple{
                          causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.wtcEffectLocation),
                          effectLocations:Sequence(Integer) = Sequence{iter.index},
                          violationType:ViolationType = ViolationType::WTOC
                        }
                      }
                    ),
                    wtcEffectLocation:Integer = iter.index,
                    notWTC:Boolean = iter.notWTC
                  }
                else
                  Tuple{
                    index:Integer = iter.index + 1,
                    i2:Integer = 1,
                    effectCriticalInstant:Integer = iter.effectCriticalInstant,
                    rollbackInstant:Integer = iter.rollbackInstant,
                    candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant),
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(
                      Tuple{
                        causeLocations:Sequence(Integer) = causeLocations,
                        effectLocations:Sequence(Integer) = Sequence{iter.wtcEffectLocation},
                        violationType:ViolationType = ViolationType::WTC
                      }
                    ),
                    wtcEffectLocation:Integer = iter.index,
                    notWTC:Boolean = iter.notWTC
                  }
                endif
              endif
            else
              if iter.wtcEffectLocation < iter.candidates.causeLocation->first() then
                Tuple{
                  index:Integer = iter.index + 1,
                  i2:Integer = 1,
                  effectCriticalInstant:Integer = iter.effectCriticalInstant,
                  rollbackInstant:Integer = iter.rollbackInstant,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations,
                  wtcEffectLocation:Integer = iter.index,
                  notWTC:Boolean = iter.notWTC
                }
              else
                Tuple{
                  index:Integer = iter.index + 1,
                  i2:Integer = 1,
                  effectCriticalInstant:Integer = iter.effectCriticalInstant,
                  rollbackInstant:Integer = iter.rollbackInstant,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations,
                  wtcEffectLocation:Integer = iter.wtcEffectLocation,
                  notWTC:Boolean = iter.notWTC
                }
              endif
            endif
          endif
        else
          let i22:Integer = iter.i2 + 1 in
          if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            Tuple{
              index:Integer = iter.index + 1,
              i2:Integer = i22,
              effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value,
              rollbackInstant:Integer = iter.rollbackInstant,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations,
              wtcEffectLocation:Integer = iter.wtcEffectLocation,
              notWTC:Boolean = iter.notWTC
            }
          else
            Tuple{
              index:Integer = iter.index + 1,
              i2:Integer = i22,
              effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value,
              rollbackInstant:Integer = iter.rollbackInstant,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations,
              wtcEffectLocation:Integer = iter.wtcEffectLocation,
              notWTC:Boolean = false
            }
          endif
        endif
      else
        if iter.candidates->notEmpty() and e = firstEffect then
          let t:Integer = elem.timestamp in
          Tuple{index:Integer = iter.index + 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = true}
        else
          Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.wtcEffectLocation < result.candidates.causeLocation->first() then
    result.violations->append(
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    )
  else
    if result.wtcEffectLocation < result.candidates.causeLocation->last() then
      result.violations->union(
        Sequence{
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.wtcEffectLocation).causeLocation,
            effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
            violationType:ViolationType = ViolationType::WTC
          },
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.wtcEffectLocation).causeLocation,
            effectLocations:Sequence(Integer) = Sequence{},
            violationType:ViolationType = ViolationType::NSOR
          }
        }
      )
    else
      result.violations->append(
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates.causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
          violationType:ViolationType = ViolationType::WTC
        }
      )
    endif
  endif
else
  result.violations
endif

-- modified on 28/08/2015
def: reportPatternResponseOneManyExactlyMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  lastEffectDistanceType:Integer = effectDistances->last().which,
  result:Tuple(index:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), lastEffectLocation:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)), wtcEffectLocation:Integer, notWTC:Boolean) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), lastEffectLocation:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)), wtcEffectLocation:Integer, notWTC:Boolean)
    = Tuple{index:Integer = begin, i2:Integer = 1, effectCriticalInstant:Integer = 0, rollbackInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, lastEffectLocation:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}, wtcEffectLocation:Integer = 0, notWTC:Boolean = true}
    |
    let e:String = elem.event in
    if e = cause then
      Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index}), lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          let causeLocations:Sequence(Integer) = iter.candidates->select(midCriticalInstant < iter.rollbackInstant).causeLocation in
          if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, lastEffectDistanceType) then
            if causeLocations->notEmpty() then
              if iter.lastEffectLocation < iter.candidates.causeLocation->first() then
                Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
              else
                if iter.lastEffectLocation < causeLocations->last() then
                  if iter.lastEffectLocation = iter.wtcEffectLocation then
                    Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTOC}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}}), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
                  else
                    Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}}), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
                  endif
                else
                  if iter.lastEffectLocation = iter.wtcEffectLocation then
                    Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation, iter.index}, violationType:ViolationType = ViolationType::LIRV}), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
                  else
                    Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation, iter.index}, violationType:ViolationType = ViolationType::WTO}), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
                  endif
                endif
              endif
            else
              Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          else
            if iter.candidates->exists(midCriticalInstant = iter.rollbackInstant) then
              let exactCauseLocation:Sequence(Integer) = iter.candidates->select(midCriticalInstant = iter.rollbackInstant).causeLocation in
              if causeLocations->notEmpty() then
                if iter.lastEffectLocation < iter.candidates.causeLocation->first() then
                  Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = exactCauseLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                else
                  if iter.lastEffectLocation < causeLocations->last() then
                    if iter.lastEffectLocation = iter.wtcEffectLocation then
                      Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTOC}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = exactCauseLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                    else
                      Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = exactCauseLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                    endif
                  else
                    if iter.lastEffectLocation = iter.wtcEffectLocation then
                      Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTOC}, Tuple{causeLocations:Sequence(Integer) = exactCauseLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                    else
                      Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = exactCauseLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                    endif
                  endif
                endif
              else
                Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = exactCauseLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
              endif
            else
              if causeLocations->notEmpty() then
                if iter.lastEffectLocation < iter.candidates.causeLocation->first() then
                  Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                else
                  if iter.lastEffectLocation < causeLocations->last() then
                    if iter.lastEffectLocation = iter.wtcEffectLocation then
                      Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTOC}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                    else
                      Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                    endif
                  else
                    if iter.lastEffectLocation = iter.wtcEffectLocation then
                      Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation, iter.index}, violationType:ViolationType = ViolationType::WTOC}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                    else
                      Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation, iter.index}, violationType:ViolationType = ViolationType::LVRI}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                    endif
                  endif
                endif
              else
                Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
              endif
            endif
          endif
        else
          let i22:Integer = iter.i2 + 1 in
          if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            Tuple{index:Integer = iter.index + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
          else
            Tuple{index:Integer = iter.index + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
          endif
        endif
      else
        if iter.candidates->notEmpty() and e = firstEffect then
          let t:Integer = elem.timestamp in
          Tuple{index:Integer = iter.index + 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = true}
        else
          Tuple{index:Integer = iter.index + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.candidates.causeLocation->first() < result.lastEffectLocation then
    if result.candidates.causeLocation->last() < result.lastEffectLocation then
      if result.lastEffectLocation = result.wtcEffectLocation then
        result.violations->append(
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates.causeLocation,
            effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
            violationType:ViolationType = ViolationType::WTOC
          }
        )
      else
        result.violations->append(
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates.causeLocation,
            effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
            violationType:ViolationType = ViolationType::WTO
          }
        )
      endif
    else
      if result.lastEffectLocation = result.wtcEffectLocation then
        result.violations->union(
          Sequence{
            Tuple{
              causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.lastEffectLocation).causeLocation,
              effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
              violationType:ViolationType = ViolationType::WTOC
            },
            Tuple{
              causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.lastEffectLocation).causeLocation,
              effectLocations:Sequence(Integer) = Sequence{},
              violationType:ViolationType = ViolationType::NSOR
            }
          }
        )
      else
        result.violations->union(
          Sequence{
            Tuple{
              causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.lastEffectLocation).causeLocation,
              effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
              violationType:ViolationType = ViolationType::WTO
            },
            Tuple{
              causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.lastEffectLocation).causeLocation,
              effectLocations:Sequence(Integer) = Sequence{},
              violationType:ViolationType = ViolationType::NSOR
            }
          }
        )
      endif
    endif
  else
    result.violations->append(
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    )
  endif
else
  result.violations
endif

--modified on 25/08/2015
def: reportPatternResponseOneManyMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, midDistance:tempsy::TimeDistance, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let midValue:Integer = midDistance.value, midWhich:tempsy::ComparingOperator = midDistance.comparingOperator in
if midWhich = tempsy::ComparingOperator::ATLEAST then
  self.reportPatternResponseOneManyAtLeastMidRight(trace, begin, end, cause, midValue, effects, effectDistances)
else
  if midWhich = tempsy::ComparingOperator::ATMOST then
    self.reportPatternResponseOneManyAtMostMidRight(trace, begin, end, cause, midValue, effects, effectDistances)
  else
    self.reportPatternResponseOneManyExactlyMidRight(trace, begin, end, cause, midValue, effects, effectDistances)
  endif
endif

/******************************************
 * =reportPatternResponseManyMany
 ******************************************
*/

-- modified on 25/08/2015
def: reportPatternResponseManyManyPlain(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, i1:Integer, i2:Integer, causeLocations:Sequence(Integer)) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, i2:Integer, causeLocations:Sequence(Integer))
    = Tuple{index:Integer = begin, i1:Integer = 1, i2:Integer = 1, causeLocations:Sequence(Integer) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, causeLocations:Sequence(Integer) = Sequence{}}
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, causeLocations:Sequence(Integer) = iter.causeLocations->append(iter.index)}
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1, causeLocations:Sequence(Integer) = iter.causeLocations}
          else
            if iter.causeLocations->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = 2, causeLocations:Sequence(Integer) = iter.causeLocations}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = 1, causeLocations:Sequence(Integer) = iter.causeLocations}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = iter.i2 + 1, causeLocations:Sequence(Integer) = iter.causeLocations}
          else
            if iter.causeLocations->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = 2, causeLocations:Sequence(Integer) = iter.causeLocations}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = 1, causeLocations:Sequence(Integer) = iter.causeLocations}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = iter.i2 + 1, causeLocations:Sequence(Integer) = iter.causeLocations}
          else
            if iter.causeLocations->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 2, causeLocations:Sequence(Integer) = iter.causeLocations}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, causeLocations:Sequence(Integer) = iter.causeLocations}
            endif
          endif
        endif
      endif
    endif
  )
in
if result.causeLocations->notEmpty() then
  Sequence{
    Tuple{
      causeLocations:Sequence(Integer) = result.causeLocations,
      effectLocations:Sequence(Integer) = Sequence{},
      violationType:ViolationType = ViolationType::NSOR
    }
  }
else
  null
endif

-- modified on 20/08/2015
def: reportPatternResponseManyManyAtLeastMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), distance:Integer, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, i1:Integer, i2:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), effectLocation:Integer) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, i2:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), effectLocation:Integer)
    = Tuple{index:Integer = begin, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, effectLocation:Integer = 0}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), effectLocation:Integer = iter.index}
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + distance, causeLocation:Integer = iter.index}), effectLocation:Integer = iter.effectLocation}
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = 2, rollbackInstant:Integer = elem.timestamp, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = 2, rollbackInstant:Integer = elem.timestamp, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 2, rollbackInstant:Integer = elem.timestamp, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
            endif
          endif
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.candidates.causeLocation->first() < result.effectLocation then
    if result.candidates.causeLocation->last() < result.effectLocation then
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates.causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.effectLocation},
          violationType:ViolationType = ViolationType::WTO
        }
      }
    else
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.effectLocation).causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.effectLocation},
          violationType:ViolationType = ViolationType::WTO
        },
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.effectLocation).causeLocation,
          effectLocations:Sequence(Integer) = Sequence{},
          violationType:ViolationType = ViolationType::NSOR
        }
      }
    endif
  else
    Sequence{
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    }
  endif
else
  null
endif

-- modified on 25/08/2015
def: reportPatternResponseManyManyAtMostMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), distance:Integer, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, i1:Integer, i2:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, i2:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      if iter.candidates->exists(midCriticalInstant < iter.rollbackInstant) then
        Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = iter.candidates->select(midCriticalInstant < iter.rollbackInstant).causeLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
      else
        Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + distance, causeLocation:Integer = iter.index}), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = 2, rollbackInstant:Integer = elem.timestamp, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = 2, rollbackInstant:Integer = elem.timestamp, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 2, rollbackInstant:Integer = elem.timestamp, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  result.violations->append(
    Tuple{
      causeLocations:Sequence(Integer) = result.candidates.causeLocation,
      effectLocations:Sequence(Integer) = Sequence{},
      violationType:ViolationType = ViolationType::NSOR
    }
  )
else
  result.violations
endif

-- modified on 25/08/2015
def: reportPatternResponseManyManyExactlyMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), distance:Integer, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, i1:Integer, i2:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), lastEffectLocation:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, i2:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), lastEffectLocation:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, lastEffectLocation:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      let causeLocations:Sequence(Integer) = iter.candidates->select(midCriticalInstant < iter.rollbackInstant).causeLocation in
      if causeLocations->notEmpty() then
        if iter.lastEffectLocation < iter.candidates.causeLocation->first() then
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
        else
          if iter.lastEffectLocation < causeLocations->last() then--separate into two violation collections
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}})}
          else
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation, iter.index}, violationType:ViolationType = ViolationType::WTO})}
          endif
        endif
      else
        Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->reject(midCriticalInstant = iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + distance, causeLocation:Integer = iter.index}), lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = 2, rollbackInstant:Integer = elem.timestamp, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = 2, rollbackInstant:Integer = elem.timestamp, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 2, rollbackInstant:Integer = elem.timestamp, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.candidates.causeLocation->first() < result.lastEffectLocation then
    if result.candidates.causeLocation->last() < result.lastEffectLocation then
      result.violations->append(
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates.causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
          violationType:ViolationType = ViolationType::WTO
        }
      )
    else
      result.violations->union(
        Sequence{
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.lastEffectLocation).causeLocation,
            effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
            violationType:ViolationType = ViolationType::WTO
          },
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.lastEffectLocation).causeLocation,
            effectLocations:Sequence(Integer) = Sequence{},
            violationType:ViolationType = ViolationType::NSOR
          }
        }
      )
    endif
  else
    result.violations->append(
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    )
  endif
else
  result.violations
endif

-- modified on 25/08/2015
def: reportPatternResponseManyManyMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), distance:tempsy::TimeDistance, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let value:Integer = distance.value, which:tempsy::ComparingOperator = distance.comparingOperator in
if which = tempsy::ComparingOperator::ATLEAST then
  self.reportPatternResponseManyManyAtLeastMid(trace, begin, end, causes, value, effects)
else
  if which = tempsy::ComparingOperator::ATMOST then
    self.reportPatternResponseManyManyAtMostMid(trace, begin, end, causes, value, effects)
  else
    self.reportPatternResponseManyManyExactlyMid(trace, begin, end, causes, value, effects)
  endif
endif

/******************************************
 * =reportPatternResponseManyManyLeft
 ******************************************
*/
-- modified on 25/08/2015
def: reportPatternResponseManyManyLeft(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, causeLocations:Sequence(Integer)) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, causeLocations:Sequence(Integer))
    = Tuple{index:Integer = begin, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, causeLocations:Sequence(Integer) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, causeLocations:Sequence(Integer) = Sequence{}}
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, causeLocations:Sequence(Integer) = iter.causeLocations->append(iter.index)}
        else
          let i11:Integer = iter.i1 + 1 in
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = iter.i2 + 1, causeLocations:Sequence(Integer) = iter.causeLocations}
          else
            if iter.causeLocations->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = 2, causeLocations:Sequence(Integer) = iter.causeLocations}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = 1, causeLocations:Sequence(Integer) = iter.causeLocations}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = iter.i2 + 1, causeLocations:Sequence(Integer) = iter.causeLocations}
          else
            if iter.causeLocations->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 2, causeLocations:Sequence(Integer) = iter.causeLocations}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1, causeLocations:Sequence(Integer) = iter.causeLocations}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1, causeLocations:Sequence(Integer) = iter.causeLocations}
          else
            if iter.causeLocations->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, causeLocations:Sequence(Integer) = iter.causeLocations}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, causeLocations:Sequence(Integer) = iter.causeLocations}
            endif
          endif
        endif
      endif
    endif
  )
in
if result.causeLocations->notEmpty() then
  Sequence{
    Tuple{
      causeLocations:Sequence(Integer) = result.causeLocations,
      effectLocations:Sequence(Integer) = Sequence{},
      violationType:ViolationType = ViolationType::NSOR
    }
  }
else
  null
endif

-- modified on 25/08/2015
def: reportPatternResponseManyManyLeftAtLeastMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), effectLocation:Integer) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), effectLocation:Integer)
    = Tuple{index:Integer = begin, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, rollbackInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, effectLocation:Integer = 0}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), effectLocation:Integer = iter.index}
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index}), effectLocation:Integer = iter.effectLocation}
        else
          let i11:Integer = iter.i1 + 1 in
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              let t:Integer = elem.timestamp in
              Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = 2, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              let t:Integer = elem.timestamp in
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance, i2:Integer = 2, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, rollbackInstant:Integer = elem.timestamp, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation}
            endif
          endif
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.candidates.causeLocation->first() < result.effectLocation then
    if result.candidates.causeLocation->last() < result.effectLocation then
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates.causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.effectLocation},
          violationType:ViolationType = ViolationType::WTO
        }
      }
    else
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.effectLocation).causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.effectLocation},
          violationType:ViolationType = ViolationType::WTO
        },
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.effectLocation).causeLocation,
          effectLocations:Sequence(Integer) = Sequence{},
          violationType:ViolationType = ViolationType::NSOR
        }
      }
    endif
  else
    Sequence{
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    }
  endif
else
  null
endif

-- modified on 25/08/2015
def: reportPatternResponseManyManyLeftAtMostMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, rollbackInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      if iter.candidates->exists(midCriticalInstant < iter.rollbackInstant) then
        Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = iter.candidates->select(midCriticalInstant < iter.rollbackInstant).causeLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
      else
        Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index}), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        else
          let i11:Integer = iter.i1 + 1 in
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              let t:Integer = elem.timestamp in
              Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = 2, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              let t:Integer = elem.timestamp in
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance, i2:Integer = 2, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, rollbackInstant:Integer = elem.timestamp, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  result.violations->append(
    Tuple{
      causeLocations:Sequence(Integer) = result.candidates.causeLocation,
      effectLocations:Sequence(Integer) = Sequence{},
      violationType:ViolationType = ViolationType::NSOR
    }
  )
else
  result.violations
endif

-- modified on 25/08/2015
def: reportPatternResponseManyManyLeftExactlyMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), lastEffectLocation:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), lastEffectLocation:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, rollbackInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, lastEffectLocation:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      let causeLocations:Sequence(Integer) = iter.candidates->select(midCriticalInstant < iter.rollbackInstant).causeLocation in
      if causeLocations->notEmpty() then
        if iter.lastEffectLocation < iter.candidates.causeLocation->first() then
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
        else
          if iter.lastEffectLocation < causeLocations->last() then--separate into two violation collections
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}})}
          else
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation, iter.index}, violationType:ViolationType = ViolationType::WTO})}
          endif
        endif
      else
        Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->reject(midCriticalInstant = iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index}), lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        else
          let i11:Integer = iter.i1 + 1 in
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              let t:Integer = elem.timestamp in
              Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = 2, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              let t:Integer = elem.timestamp in
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance, i2:Integer = 2, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, rollbackInstant:Integer = elem.timestamp, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.candidates.causeLocation->first() < result.lastEffectLocation then
    if result.candidates.causeLocation->last() < result.lastEffectLocation then
      result.violations->append(
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates.causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
          violationType:ViolationType = ViolationType::WTO
        }
      )
    else
      result.violations->union(
        Sequence{
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.lastEffectLocation).causeLocation,
            effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
            violationType:ViolationType = ViolationType::WTO
          },
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.lastEffectLocation).causeLocation,
            effectLocations:Sequence(Integer) = Sequence{},
            violationType:ViolationType = ViolationType::NSOR
          }
        }
      )
    endif
  else
    result.violations->append(
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    )
  endif
else
  result.violations
endif

-- modified on 10/06/2015
def: reportPatternResponseManyManyLeftMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:tempsy::TimeDistance, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let midValue:Integer = midDistance.value, midWhich:tempsy::ComparingOperator = midDistance.comparingOperator in
if midWhich = tempsy::ComparingOperator::ATLEAST then
  self.reportPatternResponseManyManyLeftAtLeastMid(trace, begin, end, causes, causeDistances, midValue, effects)
else
  if midWhich = tempsy::ComparingOperator::ATMOST then
    self.reportPatternResponseManyManyLeftAtMostMid(trace, begin, end, causes, causeDistances, midValue, effects)
  else
    self.reportPatternResponseManyManyLeftExactlyMid(trace, begin, end, causes, causeDistances, midValue, effects)
  endif
endif

/******************************************
 * =reportPatternResponseManyManyRight
 ******************************************
*/

-- modified on 27/08/2015
def: reportPatternResponseManyManyRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  lastEffectDistanceType:Integer = effectDistances->last().which,
  result:Tuple(index:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer, causeLocations:Sequence(Integer), wtcEffectLocation:Integer, notWTC:Boolean) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer, causeLocations:Sequence(Integer), wtcEffectLocation:Integer, notWTC:Boolean) =
    Tuple{i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0, causeLocations:Sequence(Integer) = Sequence{}, wtcEffectLocation:Integer = 0, notWTC:Boolean = true}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, lastEffectDistanceType) then
        Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, causeLocations:Sequence(Integer) = Sequence{}, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
      else
        Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, causeLocations:Sequence(Integer) = iter.causeLocations->append(iter.index), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.causeLocations->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}  
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.causeLocations->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}  
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.causeLocations->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = true}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        endif
      endif
    endif
  )
in
if result.causeLocations->notEmpty() then
  if result.causeLocations->first() < result.wtcEffectLocation then
    if result.causeLocations->last() < result.wtcEffectLocation then
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = result.causeLocations,
          effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
          violationType:ViolationType = ViolationType::WTC
        }
      }
    else
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = result.causeLocations->select(causeLocation | causeLocation < result.wtcEffectLocation),
          effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
          violationType:ViolationType = ViolationType::WTC
        },
        Tuple{
          causeLocations:Sequence(Integer) = result.causeLocations->select(causeLocation | causeLocation > result.wtcEffectLocation),
          effectLocations:Sequence(Integer) = Sequence{},
          violationType:ViolationType = ViolationType::NSOR
        }
      }
    endif
  else
    Sequence{
      Tuple{
        causeLocations:Sequence(Integer) = result.causeLocations,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    }
  endif
else
  null
endif

-- modified on 27/08/2015
def: reportPatternResponseManyManyAtLeastMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  lastEffectDistanceType:Integer = effectDistances->last().which,
  result:Tuple(index:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), effectLocation:Integer, wtcEffectLocation:Integer, notWTC:Boolean) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), effectLocation:Integer, wtcEffectLocation:Integer, notWTC:Boolean)
    = Tuple{index:Integer = begin, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0, rollbackInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, effectLocation:Integer = 0, wtcEffectLocation:Integer = 0, notWTC:Boolean = true}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, lastEffectDistanceType) then
        Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), effectLocation:Integer = iter.index, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
      else
        Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index}), effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              let t:Integer = elem.timestamp in
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              let t:Integer = elem.timestamp in
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              let t:Integer = elem.timestamp in
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = true}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.effectLocation < result.candidates.causeLocation->first() and result.wtcEffectLocation < result.candidates.causeLocation->first() then
    Sequence{
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    }
  else
    let wtoCauseLocations:Sequence(Integer) = result.candidates->select(midCriticalInstant > result.rollbackInstant).causeLocation in
    if result.effectLocation < result.wtcEffectLocation then--in this case, left WTO violations are ignored and WTC/WTOC violations are reported
      let wtcCauseLocations:Sequence(Integer) = result.candidates->select(midCriticalInstant <= result.rollbackInstant).causeLocation in
      let nsorCauseLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.wtcEffectLocation).causeLocation in
      if wtcCauseLocations->notEmpty() then
        if wtoCauseLocations->notEmpty() then
          if nsorCauseLocations->notEmpty() then
            Sequence{
              Tuple{
                causeLocations:Sequence(Integer) = wtcCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
                violationType:ViolationType = ViolationType::WTC
              },
              Tuple{
                causeLocations:Sequence(Integer) = wtoCauseLocations->select(causeLocation | causeLocation < result.wtcEffectLocation),
                effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
                violationType:ViolationType = ViolationType::WTOC
              },
              Tuple{
                causeLocations:Sequence(Integer) = nsorCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{},
                violationType:ViolationType = ViolationType::NSOR
              }
            }
          else
            Sequence{
              Tuple{
                causeLocations:Sequence(Integer) = wtcCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
                violationType:ViolationType = ViolationType::WTC
              },
              Tuple{
                causeLocations:Sequence(Integer) = wtoCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
                violationType:ViolationType = ViolationType::WTOC
              }
            }
          endif
        else
          if nsorCauseLocations->notEmpty() then
            Sequence{
              Tuple{
                causeLocations:Sequence(Integer) = wtcCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
                violationType:ViolationType = ViolationType::WTC
              },
              Tuple{
                causeLocations:Sequence(Integer) = nsorCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{},
                violationType:ViolationType = ViolationType::NSOR
              }
            }
          else
            Sequence{
              Tuple{
                causeLocations:Sequence(Integer) = wtcCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
                violationType:ViolationType = ViolationType::WTC
              }
            }
          endif
        endif
      else--wtoCauseLocations must be not empty
        if nsorCauseLocations->notEmpty() then
          Sequence{
            Tuple{
              causeLocations:Sequence(Integer) = wtoCauseLocations->select(causeLocation | causeLocation < result.wtcEffectLocation),
              effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
              violationType:ViolationType = ViolationType::WTOC
            },
            Tuple{
              causeLocations:Sequence(Integer) = nsorCauseLocations,
              effectLocations:Sequence(Integer) = Sequence{},
              violationType:ViolationType = ViolationType::NSOR
            }
          }
        else
          Sequence{
            Tuple{
              causeLocations:Sequence(Integer) = wtoCauseLocations,
              effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
              violationType:ViolationType = ViolationType::WTOC
            }
          }
        endif
      endif
    else
      let nsorCauseLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.effectLocation).causeLocation in
      if nsorCauseLocations->notEmpty() then
        Sequence{
          Tuple{
            causeLocations:Sequence(Integer) = wtoCauseLocations->select(causeLocation | causeLocation < result.effectLocation),
            effectLocations:Sequence(Integer) = Sequence{result.effectLocation},
            violationType:ViolationType = ViolationType::WTO
          },
          Tuple{
            causeLocations:Sequence(Integer) = nsorCauseLocations,
            effectLocations:Sequence(Integer) = Sequence{},
            violationType:ViolationType = ViolationType::NSOR
          }
        }
      else
        Sequence{
          Tuple{
            causeLocations:Sequence(Integer) = wtoCauseLocations,
            effectLocations:Sequence(Integer) = Sequence{result.effectLocation},
            violationType:ViolationType = ViolationType::WTO
          }
        }
      endif
    endif
  endif
else
  null
endif

-- modified on 28/08/2015
def: reportPatternResponseManyManyAtMostMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  lastEffectDistanceType:Integer = effectDistances->last().which,
  result:Tuple(index:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)), wtcEffectLocation:Integer, notWTC:Boolean) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)), wtcEffectLocation:Integer, notWTC:Boolean)
    = Tuple{index:Integer = begin, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0, rollbackInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}, wtcEffectLocation:Integer = 0, notWTC:Boolean = true}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      let causeLocations:Sequence(Integer) = iter.candidates->select(midCriticalInstant < iter.rollbackInstant).causeLocation in
      if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, lastEffectDistanceType) then
        if causeLocations->notEmpty() then
          if iter.wtcEffectLocation < iter.candidates.causeLocation->first() then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO } ), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
          else
            if iter.wtcEffectLocation < causeLocations->last() then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.wtcEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.wtcEffectLocation}, violationType:ViolationType = ViolationType::WTC}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.wtcEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}}), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.wtcEffectLocation}, violationType:ViolationType = ViolationType::WTC}), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        else
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
        endif
      else
        if causeLocations->notEmpty() then
          if iter.wtcEffectLocation < iter.candidates.causeLocation->first() then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
          else
            if iter.wtcEffectLocation < causeLocations->last() then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.wtcEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.wtcEffectLocation}, violationType:ViolationType = ViolationType::WTC}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.wtcEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTOC}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.wtcEffectLocation}, violationType:ViolationType = ViolationType::WTC}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
            endif
          endif
        else
          if iter.wtcEffectLocation < iter.candidates.causeLocation->first() then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
          else
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
          endif
        endif
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index}), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              let t:Integer = elem.timestamp in
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              let t:Integer = elem.timestamp in
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              let t:Integer = elem.timestamp in
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = true}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.wtcEffectLocation < result.candidates.causeLocation->first() then
    result.violations->append(
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    )
  else
    if result.wtcEffectLocation < result.candidates.causeLocation->last() then
      result.violations->union(
        Sequence{
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.wtcEffectLocation).causeLocation,
            effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
            violationType:ViolationType = ViolationType::WTC
          },
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.wtcEffectLocation).causeLocation,
            effectLocations:Sequence(Integer) = Sequence{},
            violationType:ViolationType = ViolationType::NSOR
          }
        }
      )
    else
      result.violations->append(
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates.causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
          violationType:ViolationType = ViolationType::WTC
        }
      )
    endif
  endif
else
  result.violations
endif

-- modified on 30/08/2015
def: reportPatternResponseManyManyExactlyMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  lastEffectDistanceType:Integer = effectDistances->last().which,
  result:Tuple(index:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), lastEffectLocation:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)), wtcEffectLocation:Integer, notWTC:Boolean) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), lastEffectLocation:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)), wtcEffectLocation:Integer, notWTC:Boolean)
    = Tuple{index:Integer = begin, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0, rollbackInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, lastEffectLocation:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}, wtcEffectLocation:Integer = 0, notWTC:Boolean = true}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      let causeLocations:Sequence(Integer) = iter.candidates->select(midCriticalInstant < iter.rollbackInstant).causeLocation in
      if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, lastEffectDistanceType) then
        if causeLocations->notEmpty() then
          if iter.lastEffectLocation < iter.candidates.causeLocation->first() then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
          else
            if iter.lastEffectLocation < causeLocations->last() then
              if iter.lastEffectLocation = iter.wtcEffectLocation then
                Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTOC}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}}), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
              else
                Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}}), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
              endif
            else
              if iter.lastEffectLocation = iter.wtcEffectLocation then
                Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation, iter.index}, violationType:ViolationType = ViolationType::LIRV}), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
              else
                Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation, iter.index}, violationType:ViolationType = ViolationType::WTO}), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
              endif
            endif
          endif
        else
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
        endif
      else
        if iter.candidates->exists(midCriticalInstant = iter.rollbackInstant) then
          let exactCauseLocation:Sequence(Integer) = iter.candidates->select(midCriticalInstant = iter.rollbackInstant).causeLocation in
          if causeLocations->notEmpty() then
            if iter.lastEffectLocation < iter.candidates.causeLocation->first() then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = exactCauseLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
            else
              if iter.lastEffectLocation < causeLocations->last() then
                if iter.lastEffectLocation = iter.wtcEffectLocation then
                  Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTOC}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = exactCauseLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                else
                  Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = exactCauseLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                endif
              else
                if iter.lastEffectLocation = iter.wtcEffectLocation then
                  Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTOC}, Tuple{causeLocations:Sequence(Integer) = exactCauseLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                else
                  Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = exactCauseLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                endif
              endif
            endif
          else
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = exactCauseLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
          endif
        else
          if causeLocations->notEmpty() then
            if iter.lastEffectLocation < iter.candidates.causeLocation->first() then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
            else
              if iter.lastEffectLocation < causeLocations->last() then
                if iter.lastEffectLocation = iter.wtcEffectLocation then
                  Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTOC}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                else
                  Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                endif
              else
                if iter.lastEffectLocation = iter.wtcEffectLocation then
                  Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation, iter.index}, violationType:ViolationType = ViolationType::WTOC}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                else
                  Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation, iter.index}, violationType:ViolationType = ViolationType::LVRI}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                endif
              endif
            endif
          else
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
          endif
        endif
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index}), lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              let t:Integer = elem.timestamp in
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              let t:Integer = elem.timestamp in
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              let t:Integer = elem.timestamp in
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = true}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.candidates.causeLocation->first() < result.lastEffectLocation then
    if result.candidates.causeLocation->last() < result.lastEffectLocation then
      if result.lastEffectLocation = result.wtcEffectLocation then
        result.violations->append(
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates.causeLocation,
            effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
            violationType:ViolationType = ViolationType::WTOC
          }
        )
      else
        result.violations->append(
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates.causeLocation,
            effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
            violationType:ViolationType = ViolationType::WTO
          }
        )
      endif
    else
      if result.lastEffectLocation = result.wtcEffectLocation then
        result.violations->union(
          Sequence{
            Tuple{
              causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.lastEffectLocation).causeLocation,
              effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
              violationType:ViolationType = ViolationType::WTOC
            },
            Tuple{
              causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.lastEffectLocation).causeLocation,
              effectLocations:Sequence(Integer) = Sequence{},
              violationType:ViolationType = ViolationType::NSOR
            }
          }
        )
      else
        result.violations->union(
          Sequence{
            Tuple{
              causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.lastEffectLocation).causeLocation,
              effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
              violationType:ViolationType = ViolationType::WTO
            },
            Tuple{
              causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.lastEffectLocation).causeLocation,
              effectLocations:Sequence(Integer) = Sequence{},
              violationType:ViolationType = ViolationType::NSOR
            }
          }
        )
      endif
    endif
  else
    result.violations->append(
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    )
  endif
else
  result.violations
endif

-- modified on 28/08/2015
def: reportPatternResponseManyManyMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), midDistance:tempsy::TimeDistance, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let midValue:Integer = midDistance.value, midWhich:tempsy::ComparingOperator = midDistance.comparingOperator in
if midWhich = tempsy::ComparingOperator::ATLEAST then
  self.reportPatternResponseManyManyAtLeastMidRight(trace, begin, end, causes, midValue, effects, effectDistances)
else
  if midWhich = tempsy::ComparingOperator::ATMOST then
    self.reportPatternResponseManyManyAtMostMidRight(trace, begin, end, causes, midValue, effects, effectDistances)
  else
    self.reportPatternResponseManyManyExactlyMidRight(trace, begin, end, causes, midValue, effects, effectDistances)
  endif
endif

/******************************************
 * =reportPatternResponseManyManyLeftRight
 ******************************************
*/

-- modified on 28/08/2015
def: reportPatternResponseManyManyLeftRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  lastEffectDistanceType:Integer = effectDistances->last().which,
  result:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer, causeLocations:Sequence(Integer), wtcEffectLocation:Integer, notWTC:Boolean) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer, causeLocations:Sequence(Integer), wtcEffectLocation:Integer, notWTC:Boolean)
    = Tuple{index:Integer = begin, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0, causeLocations:Sequence(Integer) = Sequence{}, wtcEffectLocation:Integer = 0, notWTC:Boolean = true}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, lastEffectDistanceType) then
        Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, causeLocations:Sequence(Integer) = Sequence{}, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
      else
        Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, causeLocations:Sequence(Integer) = iter.causeLocations->append(iter.index), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
        else
          let i11:Integer = iter.i1 + 1, t:Integer = elem.timestamp in
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = i22, effectCriticalInstant:Integer = t + causeDistances->at(i22).value, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = i22, effectCriticalInstant:Integer = t + causeDistances->at(i22).value, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.causeLocations->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        endif
      else
        if e = firstCause then
          let t:Integer = elem.timestamp in
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = t + secondEffectDistance, i2:Integer = i22, effectCriticalInstant:Integer = t + causeDistances->at(i22).value, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = t + secondEffectDistance, i2:Integer = i22, effectCriticalInstant:Integer = t + causeDistances->at(i22).value, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.causeLocations->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = t + secondEffectDistance, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = t + secondEffectDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + causeDistances->at(i22).value, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + causeDistances->at(i22).value, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.causeLocations->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = true}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, causeLocations:Sequence(Integer) = iter.causeLocations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        endif
      endif
    endif
  )
in
if result.causeLocations->notEmpty() then
  if result.causeLocations->first() < result.wtcEffectLocation then
    if result.causeLocations->last() < result.wtcEffectLocation then
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = result.causeLocations,
          effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
          violationType:ViolationType = ViolationType::WTC
        }
      }
    else
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = result.causeLocations->select(causeLocation | causeLocation < result.wtcEffectLocation),
          effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
          violationType:ViolationType = ViolationType::WTC
        },
        Tuple{
          causeLocations:Sequence(Integer) = result.causeLocations->select(causeLocation | causeLocation > result.wtcEffectLocation),
          effectLocations:Sequence(Integer) = Sequence{},
          violationType:ViolationType = ViolationType::NSOR
        }
      }
    endif
  else
    Sequence{
      Tuple{
        causeLocations:Sequence(Integer) = result.causeLocations,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    }
  endif
else
  null
endif

-- modified on 28/08/2015
def: reportPatternResponseManyManyLeftAtLeastMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  lastEffectDistanceType:Integer = effectDistances->last().which,
  result:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), effectLocation:Integer, wtcEffectLocation:Integer, notWTC:Boolean) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), effectLocation:Integer, wtcEffectLocation:Integer, notWTC:Boolean)
    = Tuple{index:Integer = begin, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0, rollbackInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, effectLocation:Integer = 0, wtcEffectLocation:Integer = 0, notWTC:Boolean = true}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, lastEffectDistanceType) then
        Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), effectLocation:Integer = iter.index, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
      else
        Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index}), effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
        else
          let i11:Integer = iter.i1 + 1, t:Integer = elem.timestamp in
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = i22, effectCriticalInstant:Integer = t + causeDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = i22, effectCriticalInstant:Integer = t + causeDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        endif
      else
        if e = firstCause then
          let t:Integer = elem.timestamp in
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance, i2:Integer = i22, effectCriticalInstant:Integer = t + causeDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance, i2:Integer = i22, effectCriticalInstant:Integer = t + causeDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + causeDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + causeDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.candidates->notEmpty() and e = firstEffect then
            let t:Integer = elem.timestamp in
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = true}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, effectLocation:Integer = iter.effectLocation, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.effectLocation < result.candidates.causeLocation->first() and result.wtcEffectLocation < result.candidates.causeLocation->first() then
    Sequence{
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    }
  else
    let wtoCauseLocations:Sequence(Integer) = result.candidates->select(midCriticalInstant > result.rollbackInstant).causeLocation in
    if result.effectLocation < result.wtcEffectLocation then--in this case, left WTO violations are ignored and WTC/WTOC violations are reported
      let wtcCauseLocations:Sequence(Integer) = result.candidates->select(midCriticalInstant <= result.rollbackInstant).causeLocation in
      let nsorCauseLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.wtcEffectLocation).causeLocation in
      if wtcCauseLocations->notEmpty() then
        if wtoCauseLocations->notEmpty() then
          if nsorCauseLocations->notEmpty() then
            Sequence{
              Tuple{
                causeLocations:Sequence(Integer) = wtcCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
                violationType:ViolationType = ViolationType::WTC
              },
              Tuple{
                causeLocations:Sequence(Integer) = wtoCauseLocations->select(causeLocation | causeLocation < result.wtcEffectLocation),
                effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
                violationType:ViolationType = ViolationType::WTOC
              },
              Tuple{
                causeLocations:Sequence(Integer) = nsorCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{},
                violationType:ViolationType = ViolationType::NSOR
              }
            }
          else
            Sequence{
              Tuple{
                causeLocations:Sequence(Integer) = wtcCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
                violationType:ViolationType = ViolationType::WTC
              },
              Tuple{
                causeLocations:Sequence(Integer) = wtoCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
                violationType:ViolationType = ViolationType::WTOC
              }
            }
          endif
        else
          if nsorCauseLocations->notEmpty() then
            Sequence{
              Tuple{
                causeLocations:Sequence(Integer) = wtcCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
                violationType:ViolationType = ViolationType::WTC
              },
              Tuple{
                causeLocations:Sequence(Integer) = nsorCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{},
                violationType:ViolationType = ViolationType::NSOR
              }
            }
          else
            Sequence{
              Tuple{
                causeLocations:Sequence(Integer) = wtcCauseLocations,
                effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
                violationType:ViolationType = ViolationType::WTC
              }
            }
          endif
        endif
      else--wtoCauseLocations must be not empty
        if nsorCauseLocations->notEmpty() then
          Sequence{
            Tuple{
              causeLocations:Sequence(Integer) = wtoCauseLocations->select(causeLocation | causeLocation < result.wtcEffectLocation),
              effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
              violationType:ViolationType = ViolationType::WTOC
            },
            Tuple{
              causeLocations:Sequence(Integer) = nsorCauseLocations,
              effectLocations:Sequence(Integer) = Sequence{},
              violationType:ViolationType = ViolationType::NSOR
            }
          }
        else
          Sequence{
            Tuple{
              causeLocations:Sequence(Integer) = wtoCauseLocations,
              effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
              violationType:ViolationType = ViolationType::WTOC
            }
          }
        endif
      endif
    else
      let nsorCauseLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.effectLocation).causeLocation in
      if nsorCauseLocations->notEmpty() then
        Sequence{
          Tuple{
            causeLocations:Sequence(Integer) = wtoCauseLocations->select(causeLocation | causeLocation < result.effectLocation),
            effectLocations:Sequence(Integer) = Sequence{result.effectLocation},
            violationType:ViolationType = ViolationType::WTO
          },
          Tuple{
            causeLocations:Sequence(Integer) = nsorCauseLocations,
            effectLocations:Sequence(Integer) = Sequence{},
            violationType:ViolationType = ViolationType::NSOR
          }
        }
      else
        Sequence{
          Tuple{
            causeLocations:Sequence(Integer) = wtoCauseLocations,
            effectLocations:Sequence(Integer) = Sequence{result.effectLocation},
            violationType:ViolationType = ViolationType::WTO
          }
        }
      endif
    endif
  endif
else
  null
endif

-- modified on 28/08/2015
def: reportPatternResponseManyManyLeftAtMostMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  lastEffectDistanceType:Integer = effectDistances->last().which,
  result:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)), wtcEffectLocation:Integer, notWTC:Boolean) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)), wtcEffectLocation:Integer, notWTC:Boolean)
    = Tuple{index:Integer = begin, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0, rollbackInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}, wtcEffectLocation:Integer = 0, notWTC:Boolean = true}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      let causeLocations:Sequence(Integer) = iter.candidates->select(midCriticalInstant < iter.rollbackInstant).causeLocation in
      if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, lastEffectDistanceType) then
        if causeLocations->notEmpty() then
          if iter.wtcEffectLocation < iter.candidates.causeLocation->first() then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO } ), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
          else
            if iter.wtcEffectLocation < causeLocations->last() then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.wtcEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.wtcEffectLocation}, violationType:ViolationType = ViolationType::WTC}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.wtcEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}}), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.wtcEffectLocation}, violationType:ViolationType = ViolationType::WTC}), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        else
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
        endif
      else
        if causeLocations->notEmpty() then
          if iter.wtcEffectLocation < iter.candidates.causeLocation->first() then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
          else
            if iter.wtcEffectLocation < causeLocations->last() then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.wtcEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.wtcEffectLocation}, violationType:ViolationType = ViolationType::WTC}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.wtcEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTOC}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.wtcEffectLocation}, violationType:ViolationType = ViolationType::WTC}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
            endif
          endif
        else
          if iter.wtcEffectLocation < iter.candidates.causeLocation->first() then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
          else
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
          endif
        endif
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index}), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
        else
          let i11:Integer = iter.i1 + 1, t:Integer = elem.timestamp in
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = i22, effectCriticalInstant:Integer = t + causeDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = i22, effectCriticalInstant:Integer = t + causeDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        endif
      else
        if e = firstCause then
          let t:Integer = elem.timestamp in
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance, i2:Integer = i22, effectCriticalInstant:Integer = t + causeDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance, i2:Integer = i22, effectCriticalInstant:Integer = t + causeDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.candidates->notEmpty() and e = firstEffect then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + causeDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + causeDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
            endif
          else
            if iter.candidates->notEmpty() and e = firstEffect then
            let t:Integer = elem.timestamp in
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = true}
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            endif
          endif
        endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.wtcEffectLocation < result.candidates.causeLocation->first() then
    result.violations->append(
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    )
  else
    if result.wtcEffectLocation < result.candidates.causeLocation->last() then
      result.violations->union(
        Sequence{
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.wtcEffectLocation).causeLocation,
            effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
            violationType:ViolationType = ViolationType::WTC
          },
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.wtcEffectLocation).causeLocation,
            effectLocations:Sequence(Integer) = Sequence{},
            violationType:ViolationType = ViolationType::NSOR
          }
        }
      )
    else
      result.violations->append(
        Tuple{
          causeLocations:Sequence(Integer) = result.candidates.causeLocation,
          effectLocations:Sequence(Integer) = Sequence{result.wtcEffectLocation},
          violationType:ViolationType = ViolationType::WTC
        }
      )
    endif
  endif
else
  result.violations
endif

-- modified on 30/08/2015
def: reportPatternResponseManyManyLeftExactlyMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  lastEffectDistanceType:Integer = effectDistances->last().which,
  result:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), lastEffectLocation:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)), wtcEffectLocation:Integer, notWTC:Boolean) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), lastEffectLocation:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)), wtcEffectLocation:Integer, notWTC:Boolean)
    = Tuple{index:Integer = begin, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0, rollbackInstant:Integer = 0, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, lastEffectLocation:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}, wtcEffectLocation:Integer = 0, notWTC:Boolean = true}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
        let causeLocations:Sequence(Integer) = iter.candidates->select(midCriticalInstant < iter.rollbackInstant).causeLocation in
        if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, lastEffectDistanceType) then
          if causeLocations->notEmpty() then
            if iter.lastEffectLocation < iter.candidates.causeLocation->first() then
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
            else
              if iter.lastEffectLocation < causeLocations->last() then
                if iter.lastEffectLocation = iter.wtcEffectLocation then
                  Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTOC}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}}), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
                else
                  Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}}), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
                endif
              else
                if iter.lastEffectLocation = iter.wtcEffectLocation then
                  Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation, iter.index}, violationType:ViolationType = ViolationType::LIRV}), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
                else
                  Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation, iter.index}, violationType:ViolationType = ViolationType::WTO}), wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
                endif
              endif
            endif
          else
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
          endif
        else
          if iter.candidates->exists(midCriticalInstant = iter.rollbackInstant) then
            let exactCauseLocation:Sequence(Integer) = iter.candidates->select(midCriticalInstant = iter.rollbackInstant).causeLocation in
            if causeLocations->notEmpty() then
              if iter.lastEffectLocation < iter.candidates.causeLocation->first() then
                Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = exactCauseLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
              else
                if iter.lastEffectLocation < causeLocations->last() then
                  if iter.lastEffectLocation = iter.wtcEffectLocation then
                    Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTOC}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = exactCauseLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                  else
                    Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = exactCauseLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                  endif
                else
                  if iter.lastEffectLocation = iter.wtcEffectLocation then
                    Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTOC}, Tuple{causeLocations:Sequence(Integer) = exactCauseLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                  else
                    Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = exactCauseLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                  endif
                endif
              endif
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = exactCauseLocation, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
            endif
          else
            if causeLocations->notEmpty() then
              if iter.lastEffectLocation < iter.candidates.causeLocation->first() then
                Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
              else
                if iter.lastEffectLocation < causeLocations->last() then
                  if iter.lastEffectLocation = iter.wtcEffectLocation then
                    Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTOC}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                  else
                    Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->union(Sequence{Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation < iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation}, violationType:ViolationType = ViolationType::WTO}, Tuple{causeLocations:Sequence(Integer) = causeLocations->select(causeLocation | causeLocation > iter.lastEffectLocation), effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO}}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                  endif
                else
                  if iter.lastEffectLocation = iter.wtcEffectLocation then
                    Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation, iter.index}, violationType:ViolationType = ViolationType::WTOC}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                  else
                    Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = causeLocations, effectLocations:Sequence(Integer) = Sequence{iter.lastEffectLocation, iter.index}, violationType:ViolationType = ViolationType::LVRI}), wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
                  endif
                endif
              endif
            else
              Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant), lastEffectLocation:Integer = iter.index, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}
            endif
          endif
        endif
      else
        if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
          if iter.i1 = causeSize then
            Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index}), lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
          else
            let i11:Integer = iter.i1 + 1, t:Integer = elem.timestamp in
            if iter.i2 > 1 and e = effects->at(iter.i2) then
              let i22:Integer = iter.i2 + 1 in
              if iter.notWTC and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
                Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = i22, effectCriticalInstant:Integer = t + causeDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
              else
                Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = i22, effectCriticalInstant:Integer = t + causeDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
              endif
            else
              if iter.candidates->notEmpty() and e = firstEffect then
                Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
              else
                Tuple{index:Integer = iter.index + 1, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
              endif
            endif
          endif
        else
          if e = firstCause then
            let t:Integer = elem.timestamp in
            if iter.i2 > 1 and e = effects->at(iter.i2) then
              let i22:Integer = iter.i2 + 1 in
              if iter.notWTC and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
                Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance, i2:Integer = i22, effectCriticalInstant:Integer = t + causeDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
              else
                Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance, i2:Integer = i22, effectCriticalInstant:Integer = t + causeDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
              endif
            else
              if iter.candidates->notEmpty() and e = firstEffect then
                Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
              else
                Tuple{index:Integer = iter.index + 1, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
              endif
            endif
          else
            if iter.i2 > 1 and e = effects->at(iter.i2) then
              let i22:Integer = iter.i2 + 1 in
              if iter.notWTC and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
                Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + causeDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
              else
                Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + causeDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = false}
              endif
            else
              if iter.candidates->notEmpty() and e = firstEffect then
                let t:Integer = elem.timestamp in
                Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance, rollbackInstant:Integer = t, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = true}
              else
                Tuple{index:Integer = iter.index + 1, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, lastEffectLocation:Integer = iter.lastEffectLocation, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations, wtcEffectLocation:Integer = iter.wtcEffectLocation, notWTC:Boolean = iter.notWTC}
              endif
            endif
          endif
      endif
    endif
  )
in
if result.candidates->notEmpty() then
  if result.candidates.causeLocation->first() < result.lastEffectLocation then
    if result.candidates.causeLocation->last() < result.lastEffectLocation then
      if result.lastEffectLocation = result.wtcEffectLocation then
        result.violations->append(
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates.causeLocation,
            effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
            violationType:ViolationType = ViolationType::WTOC
          }
        )
      else
        result.violations->append(
          Tuple{
            causeLocations:Sequence(Integer) = result.candidates.causeLocation,
            effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
            violationType:ViolationType = ViolationType::WTO
          }
        )
      endif
    else
      if result.lastEffectLocation = result.wtcEffectLocation then
        result.violations->union(
          Sequence{
            Tuple{
              causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.lastEffectLocation).causeLocation,
              effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
              violationType:ViolationType = ViolationType::WTOC
            },
            Tuple{
              causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.lastEffectLocation).causeLocation,
              effectLocations:Sequence(Integer) = Sequence{},
              violationType:ViolationType = ViolationType::NSOR
            }
          }
        )
      else
        result.violations->union(
          Sequence{
            Tuple{
              causeLocations:Sequence(Integer) = result.candidates->select(causeLocation < result.lastEffectLocation).causeLocation,
              effectLocations:Sequence(Integer) = Sequence{result.lastEffectLocation},
              violationType:ViolationType = ViolationType::WTO
            },
            Tuple{
              causeLocations:Sequence(Integer) = result.candidates->select(causeLocation > result.lastEffectLocation).causeLocation,
              effectLocations:Sequence(Integer) = Sequence{},
              violationType:ViolationType = ViolationType::NSOR
            }
          }
        )
      endif
    endif
  else
    result.violations->append(
      Tuple{
        causeLocations:Sequence(Integer) = result.candidates.causeLocation,
        effectLocations:Sequence(Integer) = Sequence{},
        violationType:ViolationType = ViolationType::NSOR
      }
    )
  endif
else
  result.violations
endif

-- modified on 30/08/2015
def: reportPatternResponseManyManyLeftMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:tempsy::TimeDistance, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let midValue:Integer = midDistance.value, midWhich:tempsy::ComparingOperator = midDistance.comparingOperator in
if midWhich = tempsy::ComparingOperator::ATLEAST then
  self.reportPatternResponseManyManyLeftAtLeastMidRight(trace, begin, end, causes, causeDistances, midValue, effects, effectDistances)
else
  if midWhich = tempsy::ComparingOperator::ATMOST then
    self.reportPatternResponseManyManyLeftAtMostMidRight(trace, begin, end, causes, causeDistances, midValue, effects, effectDistances)
  else
    self.reportPatternResponseManyManyLeftExactlyMidRight(trace, begin, end, causes, causeDistances, midValue, effects, effectDistances)
  endif
endif

def: reportPatternResponse(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, pattern:tempsy::Pattern): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
--check the satisfiability of the response pattern 'effect responding cause'
--in the first event in the chain 'effect', it may contains time distance to the last event in the chain 'cause'
if begin > end then
  null
else
  let orderPattern:tempsy::OrderPattern = pattern.oclAsType(tempsy::OrderPattern),
      causes:Sequence(String) = orderPattern.block2.event.name,
      causeDistances:Sequence(Tuple(which:Integer, value:Integer)) = self.loadDistances(orderPattern.block2.timeDistance),
      causeSize:Integer = causes->size(),
      effects:Sequence(String) = orderPattern.block1.event.name,
      effectDistances:Sequence(Tuple(which:Integer, value:Integer)) = self.loadDistances(orderPattern.block1.timeDistance),
      effectSize:Integer = effects->size()
  in
  if causeDistances->isEmpty() then
    if effectDistances->isEmpty() then
      if orderPattern.timeDistance->isEmpty() then
        if causeSize = 1 then
          let cause:String = causes->first() in
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.reportPatternResponseOneOnePlain(trace, begin, end, cause, effect)
          else
            self.reportPatternResponseOneManyPlain(trace, begin, end, cause, effects)
          endif
        else
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.reportPatternResponseManyOnePlain(trace, begin, end, causes, effect)
          else
            self.reportPatternResponseManyManyPlain(trace, begin, end, causes, effects)
          endif
        endif
      else
        if causeSize = 1 then
          let cause:String = causes->first() in
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.reportPatternResponseOneOneMid(trace, begin, end, cause, orderPattern.timeDistance, effect)
          else
            self.reportPatternResponseOneManyMid(trace, begin, end, cause, orderPattern.timeDistance, effects)
          endif
        else
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.reportPatternResponseManyOneMid(trace, begin, end, causes, orderPattern.timeDistance, effect)
          else
            self.reportPatternResponseManyManyMid(trace, begin, end, causes, orderPattern.timeDistance, effects)
          endif
        endif
      endif
    else
      if orderPattern.timeDistance->isEmpty() then
        if causeSize = 1 then
          let cause:String = causes->first() in
          self.reportPatternResponseOneManyRight(trace, begin, end, cause, effects, effectDistances)
        else
          self.reportPatternResponseManyManyRight(trace, begin, end, causes, effects, effectDistances)
        endif
      else
        if causeSize = 1 then
          let cause:String = causes->first() in
          self.reportPatternResponseOneManyMidRight(trace, begin, end, cause, orderPattern.timeDistance, effects, effectDistances)
        else
          self.reportPatternResponseManyManyMidRight(trace, begin, end, causes, orderPattern.timeDistance, effects, effectDistances)
        endif
      endif
    endif
  else
    if effectDistances->isEmpty() then
      if orderPattern.timeDistance->isEmpty() then
        if effectSize = 1 then
          let effect:String = effects->first() in
          self.reportPatternResponseManyOneLeft(trace, begin, end, causes, causeDistances, effect)
        else
          self.reportPatternResponseManyManyLeft(trace, begin, end, causes, causeDistances, effects)
        endif
      else
        if effectSize = 1 then
          let effect:String = effects->first() in
          self.reportPatternResponseManyOneLeftMid(trace, begin, end, causes, causeDistances, orderPattern.timeDistance, effect)
        else
          self.reportPatternResponseManyManyLeftMid(trace, begin, end, causes, causeDistances, orderPattern.timeDistance, effects)
        endif
      endif
    else
      if orderPattern.timeDistance->isEmpty() then
        self.reportPatternResponseManyManyLeftRight(trace, begin, end, causes, causeDistances, effects, effectDistances)
      else
        self.reportPatternResponseManyManyLeftMidRight(trace, begin, end, causes, causeDistances, orderPattern.timeDistance, effects, effectDistances)
      endif
    endif
  endif
endif

/******************************************
 * =reportPatternPrecedenceOneOne
 ******************************************
*/

-- modified on 26/08/2015
def: reportPatternPrecedenceOneOnePlain(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
--"cause preceding effect"
let
  result:Tuple(index:Integer, flag:Boolean, effectLocations:Sequence(Integer)) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, flag:Boolean, effectLocations:Sequence(Integer))
    = Tuple{index:Integer = begin, flag:Boolean = true, effectLocations:Sequence(Integer) = Sequence{}}
    |
    if iter.flag then
      let e:String = trace->at(iter.index).event in
      if e = cause then
        Tuple{index:Integer = iter.index + 1, flag:Boolean = false, effectLocations:Sequence(Integer) = iter.effectLocations}
      else
        if e = effect then
          Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, effectLocations:Sequence(Integer) = iter.effectLocations->append(iter.index)}
        else
          Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, effectLocations:Sequence(Integer) = iter.effectLocations}
        endif
      endif
    else
      iter
    endif
  )
in
if result.effectLocations->notEmpty() then
  Sequence{
    Tuple{
      causeLocations:Sequence(Integer) = Sequence{},
      effectLocations:Sequence(Integer) = result.effectLocations,
      violationType:ViolationType = ViolationType::NSOR
    }
  }
else
  null
endif

-- modified on 26/08/2015
def: reportPatternPrecedenceOneOneAtLeastMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, distance:Integer, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
--"cause preceding at least distance tu effect"
let
  result:Tuple(index:Integer, flag:Boolean, causeLocation:Integer, midCriticalInstant:Integer, effectLocations:Sequence(Integer)) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, flag:Boolean, causeLocation:Integer, midCriticalInstant:Integer, effectLocations:Sequence(Integer))
    = Tuple{index:Integer = begin, flag:Boolean = true, causeLocation:Integer = 0, midCriticalInstant:Integer = 0, effectLocations:Sequence(Integer) = Sequence{}}
    |
    if iter.flag then
      if iter.midCriticalInstant > 0 and elem.timestamp > iter.midCriticalInstant then
        Tuple{index:Integer = iter.index + 1, flag:Boolean = false, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = null, effectLocations:Sequence(Integer) = iter.effectLocations}
      else
        let e:String = elem.event in
        if iter.midCriticalInstant = 0 and e = cause then --catch the first occurrence of cause
          Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.index, midCriticalInstant:Integer = elem.timestamp + distance, effectLocations:Sequence(Integer) = iter.effectLocations}
        else
          if e = effect then
            Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, effectLocations:Sequence(Integer) = iter.effectLocations->append(iter.index)}
          else
            Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, effectLocations:Sequence(Integer) = iter.effectLocations}
          endif
        endif
      endif
    else
      iter
    endif
  )
in
if result.effectLocations->notEmpty() then
  if result.effectLocations->first() < result.causeLocation then
    if result.effectLocations->last() < result.causeLocation then
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = Sequence{},
          effectLocations:Sequence(Integer) = result.effectLocations,
          violationType:ViolationType = ViolationType::NSOR
        }
      }
    else
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = Sequence{},
          effectLocations:Sequence(Integer) = result.effectLocations->select(effectLocation | effectLocation < result.causeLocation),
          violationType:ViolationType = ViolationType::NSOR
        },
        Tuple{
          causeLocations:Sequence(Integer) = Sequence{result.causeLocation},
          effectLocations:Sequence(Integer) = result.effectLocations->select(effectLocation | effectLocation > result.causeLocation),
          violationType:ViolationType = ViolationType::WTO
        }
      }
    endif
  else
    Sequence{
      Tuple{
        causeLocations:Sequence(Integer) = Sequence{result.causeLocation},
        effectLocations:Sequence(Integer) = result.effectLocations,
        violationType:ViolationType = ViolationType::WTO
      }
    }
  endif
else
  null
endif

-- modified on 26/08/2015
def: reportPatternPrecedenceOneOneAtMostMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, distance:Integer, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
--"cause preceding at most distance tu effect"
let
  result:Tuple(index:Integer, causeLocation:Integer, midCriticalInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, causeLocation:Integer, midCriticalInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, causeLocation:Integer = 0, midCriticalInstant:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if e = cause then --latest cause
      Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.index, midCriticalInstant:Integer = elem.timestamp + distance, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
    else
      if e = effect and elem.timestamp > iter.midCriticalInstant then
        if iter.causeLocation > 0 then
          Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
        else
          Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}}
        endif
      else
        Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
      endif
    endif
  )
in
result.violations

-- modified on 01/09/2015
def: reportPatternPrecedenceOneOneExactlyMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, distance:Integer, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  result:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if e = cause then
      Tuple{
        index:Integer = iter.index + 1,
        candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + distance, causeLocation:Integer = iter.index}),
        violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
      }
    else
      if e = effect then
        if iter.candidates->notEmpty() then
          let t:Integer = elem.timestamp in
          if iter.candidates.midCriticalInstant->excludes(t) then
            let leftViolations:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer))= iter.candidates->select(midCriticalInstant < t), rightViolations:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > t) in
            if leftViolations->notEmpty() then
              if rightViolations->notEmpty() then--iter.effectLocations must be empty
                Tuple{
                  index:Integer = iter.index + 1,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = rightViolations,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolations->last().causeLocation, rightViolations->first().causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
                }
              else
                Tuple{
                  index:Integer = iter.index + 1,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = leftViolations->subSequence(1, 1),
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolations->last().causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
                }
              endif
            else--rightViolations is not empty and iter.effectLocations is empty
              Tuple{
                index:Integer = iter.index + 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = rightViolations,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{rightViolations->first().causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
              }
            endif
          else
            Tuple{
              index:Integer = iter.index + 1,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->reject(midCriticalInstant < t), --keep the one equal to t, in case to be reported for the next violation
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          endif
        else
          Tuple{
            index:Integer = iter.index + 1,
            candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}
          }
        endif
      else
        Tuple{
          index:Integer = iter.index + 1,
          candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
          violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
        }
      endif
    endif
  )
in
result.violations

-- modified on 15/04/2015
def: reportPatternPrecedenceOneOneMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, distance:tempsy::TimeDistance, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let value:Integer = distance.value, which:tempsy::ComparingOperator = distance.comparingOperator in
if which = tempsy::ComparingOperator::ATLEAST then
  self.reportPatternPrecedenceOneOneAtLeastMid(trace, begin, end, cause, value, effect)
else
  if which = tempsy::ComparingOperator::ATMOST then
    self.reportPatternPrecedenceOneOneAtMostMid(trace, begin, end, cause, value, effect)
  else
    self.reportPatternPrecedenceOneOneExactlyMid(trace, begin, end, cause, value, effect)
  endif
endif

/******************************************
 * =reportPatternPrecedenceManyOne
 ******************************************
*/

-- modified on 02/09/2015
def: reportPatternPrecedenceManyOnePlain(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  result:Tuple(index:Integer, flag:Boolean, i1:Integer, effectLocations:Sequence(Integer)) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, flag:Boolean, i1:Integer, effectLocations:Sequence(Integer))
    = Tuple{index:Integer = begin, flag:Boolean = true, i1:Integer = 1, effectLocations:Sequence(Integer) = Sequence{}}
    |
    if iter.flag then
      let e:String = elem.event in
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{index:Integer = iter.index + 1, flag:Boolean = false, i1:Integer = null, effectLocations:Sequence(Integer) = iter.effectLocations}
        else
          Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = iter.i1 + 1, effectLocations:Sequence(Integer) = iter.effectLocations}
        endif
      else
        if e = firstCause then
          Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 2, effectLocations:Sequence(Integer) = iter.effectLocations}
        else
          if e = effect then
            Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, effectLocations:Sequence(Integer) = iter.effectLocations->append(iter.index)}
          else
            Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, effectLocations:Sequence(Integer) = iter.effectLocations}
          endif
        endif
      endif
    else
      iter
    endif
  )
in
if result.effectLocations->notEmpty() then
  Sequence{
    Tuple{
      causeLocations:Sequence(Integer) = Sequence{},
      effectLocations:Sequence(Integer) = result.effectLocations,
      violationType:ViolationType = ViolationType::NSOR
    }
  }
else
  null
endif

-- modified on 02/09/2015
def: reportPatternPrecedenceManyOneAtLeastMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), distance:Integer, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  result:Tuple(index:Integer, flag:Boolean, causeLocation:Integer, midCriticalInstant:Integer, i1:Integer, effectLocations:Sequence(Integer)) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, flag:Boolean, causeLocation:Integer, midCriticalInstant:Integer, i1:Integer, effectLocations:Sequence(Integer))
    = Tuple{index:Integer = begin, flag:Boolean = true, causeLocation:Integer = 0, midCriticalInstant:Integer = 0, i1:Integer = 1, effectLocations:Sequence(Integer) = Sequence{}}
    |
    if iter.flag then
      if iter.midCriticalInstant > 0 and elem.timestamp > iter.midCriticalInstant then
        Tuple{index:Integer = iter.index + 1, flag:Boolean = false, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = null, i1:Integer = null, effectLocations:Sequence(Integer) = iter.effectLocations}
      else
        let e:String = elem.event in
        if iter.i1 > 1 and e = causes->at(iter.i1) then
          if iter.i1 = causeSize then
            Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.index, midCriticalInstant:Integer = elem.timestamp + distance, i1:Integer = 1, effectLocations:Sequence(Integer) = iter.effectLocations}
          else
            Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, effectLocations:Sequence(Integer) = iter.effectLocations}
          endif
        else
          if iter.midCriticalInstant = 0 and e = firstCause then
            Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, effectLocations:Sequence(Integer) = iter.effectLocations}
          else
            if e = effect then
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, effectLocations:Sequence(Integer) = iter.effectLocations->append(iter.index)}
            else
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, effectLocations:Sequence(Integer) = iter.effectLocations}
            endif
          endif
        endif
      endif
    else
      iter
    endif
  )
in
if result.effectLocations->notEmpty() then
  if result.effectLocations->first() < result.causeLocation then
    if result.effectLocations->last() < result.causeLocation then
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = Sequence{},
          effectLocations:Sequence(Integer) = result.effectLocations,
          violationType:ViolationType = ViolationType::NSOR
        }
      }
    else
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = Sequence{},
          effectLocations:Sequence(Integer) = result.effectLocations->select(effectLocation | effectLocation < result.causeLocation),
          violationType:ViolationType = ViolationType::NSOR
        },
        Tuple{
          causeLocations:Sequence(Integer) = Sequence{result.causeLocation},
          effectLocations:Sequence(Integer) = result.effectLocations->select(effectLocation | effectLocation > result.causeLocation),
          violationType:ViolationType = ViolationType::WTO
        }
      }
    endif
  else
    Sequence{
      Tuple{
        causeLocations:Sequence(Integer) = Sequence{result.causeLocation},
        effectLocations:Sequence(Integer) = result.effectLocations,
        violationType:ViolationType = ViolationType::WTO
      }
    }
  endif
else
  null
endif

-- modified on 02/09/2015
def: reportPatternPrecedenceManyOneAtMostMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), distance:Integer, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  result:Tuple(index:Integer, causeLocation:Integer, midCriticalInstant:Integer, i1:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, causeLocation:Integer, midCriticalInstant:Integer, i1:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, causeLocation:Integer = 0, midCriticalInstant:Integer = 0, i1:Integer = 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i1 > 1 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.index, midCriticalInstant:Integer = elem.timestamp + distance, i1:Integer = 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
      else
        Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
      endif
    else
      if e = firstCause then
        Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
      else
        if e = effect and elem.timestamp > iter.midCriticalInstant then
          if iter.causeLocation > 0 then
            Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
          else
            Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}}
          endif
        else
          Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        endif
      endif
    endif
  )
in
result.violations

-- modified on 02/09/2015
def: reportPatternPrecedenceManyOneExactlyMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), distance:Integer, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  result:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), i1:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), i1:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, i1:Integer = 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i1 > 1 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{
          index:Integer = iter.index + 1,
          candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + distance, causeLocation:Integer = iter.index}),
          i1:Integer = 1,
          violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
        }
      else
        Tuple{
          index:Integer = iter.index + 1,
          candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
          i1:Integer = iter.i1 + 1,
          violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
        }
      endif
    else
      if e = firstCause then
        Tuple{
          index:Integer = iter.index + 1,
          candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
          i1:Integer = 2,
          violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
        }
      else
        if e = effect then
          if iter.candidates->notEmpty() then
            let t:Integer = elem.timestamp in
            if iter.candidates.midCriticalInstant->excludes(t) then
              let leftViolations:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer))= iter.candidates->select(midCriticalInstant < t), rightViolations:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > t) in
              if leftViolations->notEmpty() then
                if rightViolations->notEmpty() then--iter.effectLocations must be empty
                  Tuple{
                    index:Integer = iter.index + 1,
                    candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = rightViolations,
                    i1:Integer = 1,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolations->last().causeLocation, rightViolations->first().causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
                  }
                else
                  Tuple{
                    index:Integer = iter.index + 1,
                    candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = leftViolations->subSequence(1, 1),
                    i1:Integer = 1,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolations->last().causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
                  }
                endif
              else--rightViolations is not empty and iter.effectLocations is empty
                Tuple{
                  index:Integer = iter.index + 1,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = rightViolations,
                  i1:Integer = 1,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{rightViolations->first().causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
                }
              endif
            else
              Tuple{
                index:Integer = iter.index + 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->reject(midCriticalInstant < t),
                i1:Integer = 1,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            endif
          else
            Tuple{
              index:Integer = iter.index + 1,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
              i1:Integer = 1,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}
            }
          endif
        else
          Tuple{
            index:Integer = iter.index + 1,
            candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates,
            i1:Integer = 1,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        endif
      endif
    endif
  )
in
result.violations

-- modified on 02/09/2015
def: reportPatternPrecedenceManyOneMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), distance:tempsy::TimeDistance, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let value:Integer = distance.value, which:tempsy::ComparingOperator=distance.comparingOperator in
if which = tempsy::ComparingOperator::ATLEAST then
  self.reportPatternPrecedenceManyOneAtLeastMid(trace, begin, end, causes, value, effect)
else
  if which = tempsy::ComparingOperator::ATMOST then
    self.reportPatternPrecedenceManyOneAtMostMid(trace, begin, end, causes, value, effect)
  else
    self.reportPatternPrecedenceManyOneExactlyMid(trace, begin, end, causes, value, effect)
  endif
endif

/******************************************
 * =reportPatternPrecedenceManyOneLeft
 ******************************************
*/

-- modified on 10/09/2015
def: reportPatternPrecedenceManyOneLeft(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  lastCauseDistanceType:Integer = causeDistances->last().which,
  result:Tuple(index:Integer, flag:Boolean, i1:Integer, causeCriticalInstant:Integer, wtcCauseLocation:Integer, notWTC:Boolean, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, flag:Boolean, i1:Integer, causeCriticalInstant:Integer, wtcCauseLocation:Integer, notWTC:Boolean, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, flag:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = 0, wtcCauseLocation:Integer = 0, notWTC:Boolean = true, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    if iter.flag then
      let e:String = elem.event in
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, lastCauseDistanceType) then
            Tuple{index:Integer = iter.index + 1, flag:Boolean = false, i1:Integer = null, causeCriticalInstant:Integer = null, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = null, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, wtcCauseLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          endif
        else
          let i11:Integer = iter.i1 + 1 in
          if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
            Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = iter.notWTC, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = false, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          endif
        endif
      else
        if e = firstCause then
          Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = true, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        else
          if e = effect then
            if iter.wtcCauseLocation > 0 then
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = iter.notWTC, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.wtcCauseLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC})}
            else
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = iter.notWTC, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}}
            endif
          else
            Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = iter.notWTC, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          endif
        endif
      endif
    else
      iter
    endif
  )
in
result.violations

-- modified on 08/09/2015
def: reportPatternPrecedenceManyOneLeftAtLeastMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  lastCauseDistanceType:Integer = causeDistances->last().which,
  result:Tuple(index:Integer, flag:Boolean, causeLocation:Integer, midCriticalInstant:Integer, wtcCauseLocation:Integer, wtcMidCriticalInstant:Integer, notWTC:Boolean, i1:Integer, causeCriticalInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, flag:Boolean, causeLocation:Integer, midCriticalInstant:Integer, wtcCauseLocation:Integer, wtcMidCriticalInstant:Integer, notWTC:Boolean, i1:Integer, causeCriticalInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, flag:Boolean = true, causeLocation:Integer = 0, midCriticalInstant:Integer = 0, wtcCauseLocation:Integer = 0, wtcMidCriticalInstant:Integer = 0, notWTC:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    if iter.flag then
      if iter.midCriticalInstant > 0 and elem.timestamp > iter.midCriticalInstant then
        Tuple{
          index:Integer = iter.index + 1,
          flag:Boolean = false,
          causeLocation:Integer = null,
          midCriticalInstant:Integer = null,
          wtcCauseLocation:Integer = null,
          wtcMidCriticalInstant:Integer = null,
          notWTC:Boolean = null,
          i1:Integer = null,
          causeCriticalInstant:Integer = null,
          violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
        }
      else
        let e:String = elem.event in
        if iter.i1 > 1 and e = causes->at(iter.i1) then
          if iter.i1 = causeSize then
            if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, lastCauseDistanceType) then
              Tuple{
                index:Integer = iter.index + 1,
                flag:Boolean = iter.flag,
                causeLocation:Integer = iter.index,
                midCriticalInstant:Integer = elem.timestamp + midDistance,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = iter.notWTC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            else
              if iter.wtcCauseLocation > 0 then
                Tuple{
                  index:Integer = iter.index + 1,
                  flag:Boolean = iter.flag,
                  causeLocation:Integer = iter.causeLocation,
                  midCriticalInstant:Integer = iter.midCriticalInstant,
                  wtcCauseLocation:Integer = iter.wtcCauseLocation,
                  wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                  notWTC:Boolean = iter.notWTC,
                  i1:Integer = 1,
                  causeCriticalInstant:Integer = iter.causeCriticalInstant,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                }
              else
                Tuple{
                  index:Integer = iter.index + 1,
                  flag:Boolean = iter.flag,
                  causeLocation:Integer = iter.causeLocation,
                  midCriticalInstant:Integer = iter.midCriticalInstant,
                  wtcCauseLocation:Integer = iter.index,
                  wtcMidCriticalInstant:Integer = elem.timestamp + midDistance,
                  notWTC:Boolean = iter.notWTC,
                  i1:Integer = 1,
                  causeCriticalInstant:Integer = iter.causeCriticalInstant,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                }
              endif
            endif
          else
            let i11:Integer = iter.i1 + 1 in
            if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
              Tuple{
                index:Integer = iter.index + 1,
                flag:Boolean = iter.flag,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = iter.notWTC,
                i1:Integer = i11,
                causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            else
              if iter.wtcCauseLocation > 0 then
                Tuple{
                  index:Integer = iter.index + 1,
                  flag:Boolean = iter.flag,
                  causeLocation:Integer = iter.causeLocation,
                  midCriticalInstant:Integer = iter.midCriticalInstant,
                  wtcCauseLocation:Integer = iter.wtcCauseLocation,
                  wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                  notWTC:Boolean = iter.notWTC,
                  i1:Integer = 1,
                  causeCriticalInstant:Integer = iter.causeCriticalInstant,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                }
              else
                Tuple{
                  index:Integer = iter.index + 1,
                  flag:Boolean = iter.flag,
                  causeLocation:Integer = iter.causeLocation,
                  midCriticalInstant:Integer = iter.midCriticalInstant,
                  wtcCauseLocation:Integer = iter.wtcCauseLocation,
                  wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                  notWTC:Boolean = false,
                  i1:Integer = i11,
                  causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                }
              endif
            endif
          endif
        else
          if iter.midCriticalInstant = 0 and e = firstCause then
            Tuple{
              index:Integer = iter.index + 1,
              flag:Boolean = iter.flag,
              causeLocation:Integer = iter.causeLocation,
              midCriticalInstant:Integer = iter.midCriticalInstant,
              wtcCauseLocation:Integer = iter.wtcCauseLocation,
              wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
              notWTC:Boolean = true,
              i1:Integer = 2,
              causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          else
            if e = effect then
              if iter.wtcCauseLocation > 0 then
                if iter.causeLocation > 0 then--LIRV
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.wtcCauseLocation,
                    wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                    notWTC:Boolean = iter.notWTC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.wtcCauseLocation, iter.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::LIRV})
                  }
                else
                  if elem.timestamp > iter.wtcMidCriticalInstant then--WTC
                    Tuple{
                      index:Integer = iter.index + 1,
                      flag:Boolean = iter.flag,
                      causeLocation:Integer = iter.causeLocation,
                      midCriticalInstant:Integer = iter.midCriticalInstant,
                      wtcCauseLocation:Integer = iter.wtcCauseLocation,
                      wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                      notWTC:Boolean = iter.notWTC,
                      i1:Integer = 1,
                      causeCriticalInstant:Integer = iter.causeCriticalInstant,
                      violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.wtcCauseLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC})
                    }
                  else--WTOC
                    Tuple{
                      index:Integer = iter.index + 1,
                      flag:Boolean = iter.flag,
                      causeLocation:Integer = iter.causeLocation,
                      midCriticalInstant:Integer = iter.midCriticalInstant,
                      wtcCauseLocation:Integer = iter.wtcCauseLocation,
                      wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                      notWTC:Boolean = iter.notWTC,
                      i1:Integer = 1,
                      causeCriticalInstant:Integer = iter.causeCriticalInstant,
                      violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.wtcCauseLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTOC})
                    }
                  endif
                endif
              else
                if iter.causeLocation > 0 then--WTO
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.wtcCauseLocation,
                    wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                    notWTC:Boolean = iter.notWTC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
                  }
                else--NSOR
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.wtcCauseLocation,
                    wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                    notWTC:Boolean = iter.notWTC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}
                  }
                endif
              endif
            else
              Tuple{
                index:Integer = iter.index + 1,
                flag:Boolean = iter.flag,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = iter.notWTC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            endif
          endif
        endif
      endif
    else
      iter
    endif
  )
in
result.violations

-- modified on 09/09/2015
def: reportPatternPrecedenceManyOneLeftAtMostMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  lastCauseDistanceType:Integer = causeDistances->last().which,
  result:Tuple(index:Integer, causeLocation:Integer, midCriticalInstant:Integer, wtcCauseLocation:Integer, wtcMidCriticalInstant:Integer, notWTC:Boolean, i1:Integer, causeCriticalInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, causeLocation:Integer, midCriticalInstant:Integer, wtcCauseLocation:Integer, wtcMidCriticalInstant:Integer, notWTC:Boolean, i1:Integer, causeCriticalInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, causeLocation:Integer = 0, midCriticalInstant:Integer = 0, wtcCauseLocation:Integer = 0, wtcMidCriticalInstant:Integer = 0, notWTC:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i1 > 1 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, lastCauseDistanceType) then
          Tuple{
            index:Integer = iter.index + 1,
            causeLocation:Integer = iter.index,
            midCriticalInstant:Integer = elem.timestamp + midDistance,
            wtcCauseLocation:Integer = iter.wtcCauseLocation,
            wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
            notWTC:Boolean = iter.notWTC,
            i1:Integer = 1,
            causeCriticalInstant:Integer = iter.causeCriticalInstant,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        else
          Tuple{
            index:Integer = iter.index + 1,
            causeLocation:Integer = iter.causeLocation,
            midCriticalInstant:Integer = iter.midCriticalInstant,
            wtcCauseLocation:Integer = iter.index,
            wtcMidCriticalInstant:Integer = elem.timestamp + midDistance,
            notWTC:Boolean = iter.notWTC,
            i1:Integer = 1,
            causeCriticalInstant:Integer = iter.causeCriticalInstant,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        endif
      else
        let i11:Integer = iter.i1 + 1 in
        if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
          Tuple{
            index:Integer = iter.index + 1,
            causeLocation:Integer = iter.causeLocation,
            midCriticalInstant:Integer = iter.midCriticalInstant,
            wtcCauseLocation:Integer = iter.wtcCauseLocation,
            wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
            notWTC:Boolean = iter.notWTC,
            i1:Integer = i11,
            causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        else
          Tuple{
            index:Integer = iter.index + 1,
            causeLocation:Integer = iter.causeLocation,
            midCriticalInstant:Integer = iter.midCriticalInstant,
            wtcCauseLocation:Integer = iter.wtcCauseLocation,
            wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
            notWTC:Boolean = false,
            i1:Integer = i11,
            causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        endif
      endif
    else
      if e = firstCause then
        Tuple{
          index:Integer = iter.index + 1,
          causeLocation:Integer = iter.causeLocation,
          midCriticalInstant:Integer = iter.midCriticalInstant,
          wtcCauseLocation:Integer = iter.wtcCauseLocation,
          wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
          notWTC:Boolean = true,
          i1:Integer = 2,
          causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
          violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
        }
      else
        if e = effect and elem.timestamp > iter.midCriticalInstant then
          if iter.causeLocation = 0 then
            if iter.wtcCauseLocation = 0 then
              Tuple{
                index:Integer = iter.index + 1,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = iter.notWTC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}
              }
            else
              Tuple{
                index:Integer = iter.index + 1,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = iter.notWTC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.wtcCauseLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC})
              }
            endif
          else
            if iter.wtcCauseLocation > iter.causeLocation then
              if elem.timestamp < iter.wtcMidCriticalInstant then--LVRI
                Tuple{
                  index:Integer = iter.index + 1,
                  causeLocation:Integer = iter.causeLocation,
                  midCriticalInstant:Integer = iter.midCriticalInstant,
                  wtcCauseLocation:Integer = iter.wtcCauseLocation,
                  wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                  notWTC:Boolean = iter.notWTC,
                  i1:Integer = 1,
                  causeCriticalInstant:Integer = iter.causeCriticalInstant,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.causeLocation, iter.wtcCauseLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::LVRI})
                }
              else
                Tuple{
                  index:Integer = iter.index + 1,
                  causeLocation:Integer = iter.causeLocation,
                  midCriticalInstant:Integer = iter.midCriticalInstant,
                  wtcCauseLocation:Integer = iter.wtcCauseLocation,
                  wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                  notWTC:Boolean = iter.notWTC,
                  i1:Integer = 1,
                  causeCriticalInstant:Integer = iter.causeCriticalInstant,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.wtcCauseLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTOC})
                }
              endif
            else
              Tuple{
                index:Integer = iter.index + 1,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = iter.notWTC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
              }
            endif
          endif
        else
          Tuple{
            index:Integer = iter.index + 1,
            causeLocation:Integer = iter.causeLocation,
            midCriticalInstant:Integer = iter.midCriticalInstant,
            wtcCauseLocation:Integer = iter.wtcCauseLocation,
            wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
            notWTC:Boolean = iter.notWTC,
            i1:Integer = 1,
            causeCriticalInstant:Integer = iter.causeCriticalInstant,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        endif
      endif
    endif
  )
in
result.violations

-- modified on 10/09/2015
def: reportPatternPrecedenceManyOneLeftExactlyMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  lastCauseDistanceType:Integer = causeDistances->last().which,
  result:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)), notWTC:Boolean, i1:Integer, causeCriticalInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)), notWTC:Boolean, i1:Integer, causeCriticalInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = Sequence{}, notWTC:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i1 > 1 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, lastCauseDistanceType) then
          Tuple{
            index:Integer = iter.index + 1,
            candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}),
            notWTC:Boolean = iter.notWTC,
            i1:Integer = 1,
            causeCriticalInstant:Integer = iter.causeCriticalInstant,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        else
          Tuple{
            index:Integer = iter.index + 1,
            candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index, notWTC:Boolean = false}),
            notWTC:Boolean = iter.notWTC,
            i1:Integer = 1,
            causeCriticalInstant:Integer = iter.causeCriticalInstant,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        endif
      else
        let i11:Integer = iter.i1 + 1 in
        if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
          Tuple{
            index:Integer = iter.index + 1,
            candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
            notWTC:Boolean = iter.notWTC,
            i1:Integer = i11,
            causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        else
          Tuple{
            index:Integer = iter.index + 1,
            candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
            notWTC:Boolean = false,
            i1:Integer = i11,
            causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        endif
      endif
    else
      if e = firstCause then
        Tuple{
          index:Integer = iter.index + 1,
          candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
          notWTC:Boolean = true,
          i1:Integer = 2,
          causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
          violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
        }
      else
        if e = effect then
          if iter.candidates->notEmpty() then
            let t:Integer = elem.timestamp in
            if iter.candidates.midCriticalInstant->excludes(t) then
              let leftViolations:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates->select(midCriticalInstant < t), rightViolations:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates->select(midCriticalInstant > t) in
              if leftViolations->notEmpty() then
                let leftViolation:Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean) = leftViolations->last() in
                if rightViolations->notEmpty() then
                  let rightViolation:Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean) = rightViolations->first() in
                  if leftViolation.notWTC then
                    if rightViolation.notWTC then
                      Tuple{
                        index:Integer = iter.index + 1,
                        candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = rightViolations,
                        notWTC:Boolean = iter.notWTC,
                        i1:Integer = 1,
                        causeCriticalInstant:Integer = iter.causeCriticalInstant,
                        violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolation.causeLocation, rightViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
                      }
                    else
                      Tuple{
                        index:Integer = iter.index + 1,
                        candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = rightViolations,
                        notWTC:Boolean = iter.notWTC,
                        i1:Integer = 1,
                        causeCriticalInstant:Integer = iter.causeCriticalInstant,
                        violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolation.causeLocation, rightViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::LVRI})
                      }
                    endif
                  else
                    if rightViolation.notWTC then
                      Tuple{
                        index:Integer = iter.index + 1,
                        candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = rightViolations,
                        notWTC:Boolean = iter.notWTC,
                        i1:Integer = 1,
                        causeCriticalInstant:Integer = iter.causeCriticalInstant,
                        violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolation.causeLocation, rightViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::LIRV})
                      }
                    else
                      Tuple{
                        index:Integer = iter.index + 1,
                        candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = rightViolations,
                        notWTC:Boolean = iter.notWTC,
                        i1:Integer = 1,
                        causeCriticalInstant:Integer = iter.causeCriticalInstant,
                        violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolation.causeLocation, rightViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::LIRI})
                      }
                    endif
                  endif
                else
                  if leftViolation.notWTC then
                    Tuple{
                      index:Integer = iter.index + 1,
                      candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = Sequence{leftViolation},
                      notWTC:Boolean = iter.notWTC,
                      i1:Integer = 1,
                      causeCriticalInstant:Integer = iter.causeCriticalInstant,
                      violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
                    }
                  else
                    Tuple{
                      index:Integer = iter.index + 1,
                      candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = Sequence{leftViolation},
                      notWTC:Boolean = iter.notWTC,
                      i1:Integer = 1,
                      causeCriticalInstant:Integer = iter.causeCriticalInstant,
                      violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTOC})
                    }
                  endif
                endif
              else--if rightViolations->notEmpty() then
                let rightViolation:Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean) = rightViolations->first() in
                if rightViolation.notWTC then
                  Tuple{
                    index:Integer = iter.index + 1,
                    candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = rightViolations,
                    notWTC:Boolean = iter.notWTC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{rightViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
                  }
                else
                  Tuple{
                    index:Integer = iter.index + 1,
                    candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = rightViolations,
                    notWTC:Boolean = iter.notWTC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{rightViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTOC})
                  }
                endif
              endif
            else
              let violation:Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean) = iter.candidates->select(midCriticalInstant = t)->first() in
              if not violation.notWTC then
                Tuple{
                  index:Integer = iter.index + 1,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates->reject(midCriticalInstant < t),
                  notWTC:Boolean = iter.notWTC,
                  i1:Integer = 1,
                  causeCriticalInstant:Integer = iter.causeCriticalInstant,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{violation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC})
                }
              else
                Tuple{
                  index:Integer = iter.index + 1,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates->reject(midCriticalInstant < t),
                  notWTC:Boolean = iter.notWTC,
                  i1:Integer = 1,
                  causeCriticalInstant:Integer = iter.causeCriticalInstant,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                }
              endif
            endif
          else
            Tuple{
              index:Integer = iter.index + 1,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
              notWTC:Boolean = iter.notWTC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}
            }
          endif
        else
          Tuple{
            index:Integer = iter.index + 1,
            candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
            notWTC:Boolean = iter.notWTC,
            i1:Integer = 1,
            causeCriticalInstant:Integer = iter.causeCriticalInstant,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
          }
        endif
      endif
    endif
  )
in
result.violations

-- modified on 03/09/2015
def: reportPatternPrecedenceManyOneLeftMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:tempsy::TimeDistance, effect:String): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let midValue:Integer = midDistance.value, midWhich:tempsy::ComparingOperator=midDistance.comparingOperator in
if midWhich = tempsy::ComparingOperator::ATLEAST then
  self.reportPatternPrecedenceManyOneLeftAtLeastMid(trace, begin, end, causes, causeDistances, midValue, effect)
else
  if midWhich = tempsy::ComparingOperator::ATMOST then
    self.reportPatternPrecedenceManyOneLeftAtMostMid(trace, begin, end, causes, causeDistances, midValue, effect)
  else
    self.reportPatternPrecedenceManyOneLeftExactlyMid(trace, begin, end, causes, causeDistances, midValue, effect)
  endif
endif

/******************************************
 * =reportPatternPrecedenceOneMany
 ******************************************
*/

-- modified on 03/09/2015
def: reportPatternPrecedenceOneManyPlain(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  result:Tuple(index:Integer, flag:Boolean, i2:Integer, effectLocations:Sequence(Integer)) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, flag:Boolean, i2:Integer, effectLocations:Sequence(Integer))
    = Tuple{index:Integer = begin, flag:Boolean = true, i2:Integer = 1, effectLocations:Sequence(Integer) = Sequence{}}
    |
    if iter.flag then
      let e:String = elem.event in
      if e = cause then
        Tuple{index:Integer = iter.index + 1, flag:Boolean = false, i2:Integer = null, effectLocations:Sequence(Integer) = iter.effectLocations}
      else
        if iter.i2 > 1 and e = effects->at(iter.i2) then
          if iter.i2 = effectSize then
            Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i2:Integer = 1, effectLocations:Sequence(Integer) = iter.effectLocations->append(iter.index)}
          else
            Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i2:Integer = iter.i2 + 1, effectLocations:Sequence(Integer) = iter.effectLocations}
          endif
        else
          if e = firstEffect then
            Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i2:Integer = 2, effectLocations:Sequence(Integer) = iter.effectLocations}
          else
            Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i2:Integer = 1, effectLocations:Sequence(Integer) = iter.effectLocations}
          endif
        endif
      endif
    else
      iter
    endif
  )
in
if result.effectLocations->notEmpty() then
  Sequence{
    Tuple{
      causeLocations:Sequence(Integer) = Sequence{},
      effectLocations:Sequence(Integer) = result.effectLocations,
      violationType:ViolationType = ViolationType::NSOR
    }
  }
else
  null
endif

-- modified on 03/09/2015
def: reportPatternPrecedenceOneManyAtLeastMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, distance:Integer, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  result:Tuple(index:Integer, flag:Boolean, causeLocation:Integer, midCriticalInstant:Integer, i2:Integer, effectLocations:Sequence(Integer)) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, flag:Boolean, causeLocation:Integer, midCriticalInstant:Integer, i2:Integer, effectLocations:Sequence(Integer))
    = Tuple{index:Integer = begin, flag:Boolean = true, causeLocation:Integer = 0, midCriticalInstant:Integer = 0, i2:Integer = 1, effectLocations:Sequence(Integer) = Sequence{}}
    |
    if iter.flag then
      if iter.midCriticalInstant > 0 and elem.timestamp > iter.midCriticalInstant and iter.i2 = 1 then--need to ensure that iter.i2 = 1, so that no violation is missed
        Tuple{index:Integer = iter.index + 1, flag:Boolean = false, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = null, i2:Integer = null, effectLocations:Sequence(Integer) = iter.effectLocations}
      else
        let e:String = elem.event in
        if iter.midCriticalInstant = 0 and e = cause then --catch the first occurrence of cause
          Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.index, midCriticalInstant:Integer = elem.timestamp + distance, i2:Integer = 1, effectLocations:Sequence(Integer) = iter.effectLocations}
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            if iter.i2 = effectSize then
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectLocations:Sequence(Integer) = iter.effectLocations->append(iter.index)}
            else
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = iter.i2 + 1, effectLocations:Sequence(Integer) = iter.effectLocations}
            endif
          else
            if e = firstEffect then
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 2, effectLocations:Sequence(Integer) = iter.effectLocations}
            else
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectLocations:Sequence(Integer) = iter.effectLocations}
            endif
          endif
        endif
      endif
    else
      iter
    endif
  )
in
if result.effectLocations->notEmpty() then
  if result.effectLocations->first() < result.causeLocation then
    if result.effectLocations->last() < result.causeLocation then
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = Sequence{},
          effectLocations:Sequence(Integer) = result.effectLocations,
          violationType:ViolationType = ViolationType::NSOR
        }
      }
    else
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = Sequence{},
          effectLocations:Sequence(Integer) = result.effectLocations->select(effectLocation | effectLocation < result.causeLocation),
          violationType:ViolationType = ViolationType::NSOR
        },
        Tuple{
          causeLocations:Sequence(Integer) = Sequence{result.causeLocation},
          effectLocations:Sequence(Integer) = result.effectLocations->select(effectLocation | effectLocation > result.causeLocation),
          violationType:ViolationType = ViolationType::WTO
        }
      }
    endif
  else
    Sequence{
      Tuple{
        causeLocations:Sequence(Integer) = Sequence{result.causeLocation},
        effectLocations:Sequence(Integer) = result.effectLocations,
        violationType:ViolationType = ViolationType::WTO
      }
    }
  endif
else
  null
endif

-- modified on 03/09/2015
def: reportPatternPrecedenceOneManyAtMostMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, distance:Integer, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  result:Tuple(index:Integer, causeLocation:Integer, midCriticalInstant:Integer, i2:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, causeLocation:Integer, midCriticalInstant:Integer, i2:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, causeLocation:Integer = 0, midCriticalInstant:Integer = 0, i2:Integer = 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if e = cause then
      Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.index, midCriticalInstant:Integer = elem.timestamp + distance, i2:Integer = 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          if iter.causeLocation > 0 then
            Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
          else
            Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}}
          endif
        else
          Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = iter.i2 + 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        endif
      else
        if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
          Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 2, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        else
          Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        endif
      endif
    endif
  )
in
result.violations

-- modified on 03/09/2015
def: reportPatternPrecedenceOneManyExactlyMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, distance:Integer, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  result:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), i2:Integer, rollbackInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), i2:Integer, rollbackInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, i2:Integer = 1, rollbackInstant:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if e = cause then
      Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + distance, causeLocation:Integer = iter.index}), i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          if iter.candidates->notEmpty() then
            if iter.candidates.midCriticalInstant->excludes(iter.rollbackInstant) then
              let leftViolations:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer))= iter.candidates->select(midCriticalInstant < iter.rollbackInstant), rightViolations:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant) in
              if leftViolations->notEmpty() then
                if rightViolations->notEmpty() then--iter.effectLocations must be empty
                  Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = rightViolations, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolations->last().causeLocation, rightViolations->first().causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
                else
                  Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = leftViolations->subSequence(1, 1), i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolations->last().causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
                endif
              else
                Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = rightViolations, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{rightViolations->first().causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
              endif
            else
              Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->reject(midCriticalInstant < iter.rollbackInstant), i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          else
            Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}}
          endif
        else
          Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        endif
      else
        if e = firstEffect then
          Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i2:Integer = 2, rollbackInstant:Integer = elem.timestamp, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        else
          Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        endif
      endif
    endif
  )
in
result.violations

-- modified on 03/09/2015
def: reportPatternPrecedenceOneManyMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, distance:tempsy::TimeDistance, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let value:Integer = distance.value, which:tempsy::ComparingOperator = distance.comparingOperator in
if which = tempsy::ComparingOperator::ATLEAST then
  self.reportPatternPrecedenceOneManyAtLeastMid(trace, begin, end, cause, value, effects)
else
  if which = tempsy::ComparingOperator::ATMOST then
    self.reportPatternPrecedenceOneManyAtMostMid(trace, begin, end, cause, value, effects)
  else
    self.reportPatternPrecedenceOneManyExactlyMid(trace, begin, end, cause, value, effects)
  endif
endif

/******************************************
 * =reportPatternPrecedenceOneManyRight
 ******************************************
*/

-- modified on 04/09/2015
def: reportPatternPrecedenceOneManyRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  result:Tuple(index:Integer, flag:Boolean, i2:Integer, effectCriticalInstant:Integer, effectLocations:Sequence(Integer)) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, flag:Boolean, i2:Integer, effectCriticalInstant:Integer, effectLocations:Sequence(Integer))
    = Tuple{index:Integer = begin, flag:Boolean = true, i2:Integer = 1, effectCriticalInstant:Integer = 0, effectLocations:Sequence(Integer) = Sequence{}}
    |
    if iter.flag then
      let e:String = elem.event in
      if e = cause then
        Tuple{index:Integer = iter.index + 1, flag:Boolean = false, i2:Integer = null, effectCriticalInstant:Integer = null, effectLocations:Sequence(Integer) = iter.effectLocations}
      else
        if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          if iter.i2 = effectSize then
            Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, effectLocations:Sequence(Integer) = iter.effectLocations->append(iter.index)}
          else
            let i22:Integer = iter.i2 + 1 in
            Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, effectLocations:Sequence(Integer) = iter.effectLocations}
          endif
        else
          if e = firstEffect then
            Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, effectLocations:Sequence(Integer) = iter.effectLocations}
          else
            Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, effectLocations:Sequence(Integer) = iter.effectLocations}
          endif
        endif
      endif
    else
      iter
    endif
  )
in
if result.effectLocations->notEmpty() then
  Sequence{
    Tuple{
      causeLocations:Sequence(Integer) = Sequence{},
      effectLocations:Sequence(Integer) = result.effectLocations,
      violationType:ViolationType = ViolationType::NSOR
    }
  }
else
  null
endif

-- modified on 04/09/2015
def: reportPatternPrecedenceOneManyAtLeastMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  result:Tuple(index:Integer, flag:Boolean, causeLocation:Integer, midCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer, effectLocations:Sequence(Integer)) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, flag:Boolean, causeLocation:Integer, midCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer, effectLocations:Sequence(Integer))
    = Tuple{index:Integer = begin, flag:Boolean = true, causeLocation:Integer = 0, midCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0, effectLocations:Sequence(Integer) = Sequence{}}
    |
    if iter.flag then
      if iter.midCriticalInstant > 0 and elem.timestamp > iter.midCriticalInstant and iter.i2 = 1 then--need to ensure that iter.i2 = 1, so that no violation is missed
        Tuple{index:Integer = iter.index + 1, flag:Boolean = false, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null, effectLocations:Sequence(Integer) = iter.effectLocations}
      else
        let e:String = elem.event in
        if iter.midCriticalInstant = 0 and e = cause then --catch the first occurrence of cause
          Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.index, midCriticalInstant:Integer = elem.timestamp + midDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, effectLocations:Sequence(Integer) = iter.effectLocations}
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            if iter.i2 = effectSize then
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, effectLocations:Sequence(Integer) = iter.effectLocations->append(iter.index)}
            else
              let i22:Integer = iter.i2 + 1 in
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, effectLocations:Sequence(Integer) = iter.effectLocations}
            endif
          else
            if e = firstEffect then
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, effectLocations:Sequence(Integer) = iter.effectLocations}
            else
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, effectLocations:Sequence(Integer) = iter.effectLocations}
            endif
          endif
        endif
      endif
    else
      iter
    endif
  )
in
if result.effectLocations->notEmpty() then
  if result.effectLocations->first() < result.causeLocation then
    if result.effectLocations->last() < result.causeLocation then
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = Sequence{},
          effectLocations:Sequence(Integer) = result.effectLocations,
          violationType:ViolationType = ViolationType::NSOR
        }
      }
    else
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = Sequence{},
          effectLocations:Sequence(Integer) = result.effectLocations->select(effectLocation | effectLocation < result.causeLocation),
          violationType:ViolationType = ViolationType::NSOR
        },
        Tuple{
          causeLocations:Sequence(Integer) = Sequence{result.causeLocation},
          effectLocations:Sequence(Integer) = result.effectLocations->select(effectLocation | effectLocation > result.causeLocation),
          violationType:ViolationType = ViolationType::WTO
        }
      }
    endif
  else
    Sequence{
      Tuple{
        causeLocations:Sequence(Integer) = Sequence{result.causeLocation},
        effectLocations:Sequence(Integer) = result.effectLocations,
        violationType:ViolationType = ViolationType::WTO
      }
    }
  endif
else
  null
endif

-- modified on 04/09/2015
def: reportPatternPrecedenceOneManyAtMostMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  result:Tuple(index:Integer, causeLocation:Integer, midCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, causeLocation:Integer, midCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, causeLocation:Integer = 0, midCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if e = cause then
      Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.index, midCriticalInstant:Integer = elem.timestamp + midDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = effectSize then
          if iter.causeLocation > 0 then
            Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
          else
            Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}}
          endif
        else
          let i22:Integer = iter.i2 + 1 in
          Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        endif
      else
        if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
          Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        else
          Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        endif
      endif
    endif
  )
in
result.violations

-- modified on 04/09/2015
def: reportPatternPrecedenceOneManyExactlyMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  result:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, i2:Integer = 1, effectCriticalInstant:Integer = 0, rollbackInstant:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if e = cause then
      Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index}), i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = effectSize then
          if iter.candidates->notEmpty() then
            if iter.candidates.midCriticalInstant->excludes(iter.rollbackInstant) then
              let leftViolations:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer))= iter.candidates->select(midCriticalInstant < iter.rollbackInstant), rightViolations:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant) in
              if leftViolations->notEmpty() then
                if rightViolations->notEmpty() then--iter.effectLocations must be empty
                  Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = rightViolations, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolations->last().causeLocation, rightViolations->first().causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
                else
                  Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = leftViolations->subSequence(1, 1), i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolations->last().causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
                endif
              else
                Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = rightViolations, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{rightViolations->first().causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
              endif
            else
              Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->reject(midCriticalInstant < iter.rollbackInstant), i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          else
            Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}}
          endif
        else
          let i22:Integer = iter.i2 + 1 in
          Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        endif
      else
        if e = firstEffect then
          Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, rollbackInstant:Integer = elem.timestamp, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        else
          Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        endif
      endif
    endif
  )
in
result.violations

-- modified on 04/09/2015
def: reportPatternPrecedenceOneManyMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, cause:String, midDistance:tempsy::TimeDistance, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let midValue:Integer = midDistance.value, midWhich:tempsy::ComparingOperator=midDistance.comparingOperator in
if midWhich = tempsy::ComparingOperator::ATLEAST then
  self.reportPatternPrecedenceOneManyAtLeastMidRight(trace, begin, end, cause, midValue, effects, effectDistances)
else
  if midWhich = tempsy::ComparingOperator::ATMOST then
    self.reportPatternPrecedenceOneManyAtMostMidRight(trace, begin, end, cause, midValue, effects, effectDistances)
  else
    self.reportPatternPrecedenceOneManyExactlyMidRight(trace, begin, end, cause, midValue, effects, effectDistances)
  endif
endif

/******************************************
 * =reportPatternPrecedenceManyMany
 ******************************************
*/

-- modified on 03/09/2015
def: reportPatternPrecedenceManyManyPlain(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, flag:Boolean, i1:Integer, i2:Integer, effectLocations:Sequence(Integer)) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, flag:Boolean, i1:Integer, i2:Integer, effectLocations:Sequence(Integer))
    = Tuple{index:Integer = begin, flag:Boolean = true, i1:Integer = 1, i2:Integer = 1, effectLocations:Sequence(Integer) = Sequence{}}
    |
    if iter.flag then
      let e:String = elem.event in
      if iter.i2 = effectSize and e = lastEffect then
        Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, i2:Integer = 1, effectLocations:Sequence(Integer) = iter.effectLocations->append(iter.index)}
      else
        if iter.i1 > 1 and e = causes->at(iter.i1) then
          if iter.i1 = causeSize then
            Tuple{index:Integer = iter.index + 1, flag:Boolean = false, i1:Integer = null, i2:Integer = null, effectLocations:Sequence(Integer) = iter.effectLocations}
          else
            if iter.i2 > 1 and e = effects->at(iter.i2) then
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1, effectLocations:Sequence(Integer) = iter.effectLocations}
            else
              if e = firstEffect then
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectLocations:Sequence(Integer) = iter.effectLocations}
              else
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectLocations:Sequence(Integer) = iter.effectLocations}
              endif
            endif
          endif
        else
          if e = firstCause then
            if iter.i2 > 1 and e = effects->at(iter.i2) then
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 2, i2:Integer = iter.i2 + 1, effectLocations:Sequence(Integer) = iter.effectLocations}
            else
              if e = firstEffect then
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 2, i2:Integer = 2, effectLocations:Sequence(Integer) = iter.effectLocations}
              else
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 2, i2:Integer = 1, effectLocations:Sequence(Integer) = iter.effectLocations}
              endif
            endif
          else
            if iter.i2 > 1 and e = effects->at(iter.i2) then
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, i2:Integer = iter.i2 + 1, effectLocations:Sequence(Integer) = iter.effectLocations}
            else
              if e = firstEffect then
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, i2:Integer = 2, effectLocations:Sequence(Integer) = iter.effectLocations}
              else
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, i2:Integer = 1, effectLocations:Sequence(Integer) = iter.effectLocations}
              endif
            endif
          endif
        endif
      endif
    else
      iter
    endif
  )
in
if result.effectLocations->notEmpty() then
  Sequence{
    Tuple{
      causeLocations:Sequence(Integer) = Sequence{},
      effectLocations:Sequence(Integer) = result.effectLocations,
      violationType:ViolationType = ViolationType::NSOR
    }
  }
else
  null
endif

-- modified on 03/09/2015
def: reportPatternPrecedenceManyManyAtLeastMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), distance:Integer, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, flag:Boolean, causeLocation:Integer, midCriticalInstant:Integer, i1:Integer, i2:Integer, effectLocations:Sequence(Integer)) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, flag:Boolean, causeLocation:Integer, midCriticalInstant:Integer, i1:Integer, i2:Integer, effectLocations:Sequence(Integer))
    = Tuple{index:Integer = begin, flag:Boolean = true, causeLocation:Integer = 0, midCriticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1, effectLocations:Sequence(Integer) = Sequence{}} |
    if iter.flag then
      if iter.midCriticalInstant > 0 and elem.timestamp > iter.midCriticalInstant and iter.i2 = 1 then
        Tuple{index:Integer = iter.index + 1, flag:Boolean = false, causeLocation:Integer = null, midCriticalInstant:Integer = null, i1:Integer = null, i2:Integer = null, effectLocations:Sequence(Integer) = iter.effectLocations}
      else
        let e:String = elem.event in
        if iter.i2 = effectSize and e = lastEffect then
          Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectLocations:Sequence(Integer) = iter.effectLocations->append(iter.index)}
        else
          if iter.i1 > 1 and e = causes->at(iter.i1) then
            if iter.i1 = causeSize then
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.index, midCriticalInstant:Integer = elem.timestamp + distance, i1:Integer = 1, i2:Integer = 1, effectLocations:Sequence(Integer) = iter.effectLocations}
            else
              if iter.i2 > 1 and e = effects->at(iter.i2) then
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1, effectLocations:Sequence(Integer) = iter.effectLocations}
              else
                if e = firstEffect then
                  Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectLocations:Sequence(Integer) = iter.effectLocations}
                else
                  Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectLocations:Sequence(Integer) = iter.effectLocations}
                endif
              endif
            endif
          else
            if iter.midCriticalInstant = 0 and e = firstCause then
              if iter.i2 > 1 and e = effects->at(iter.i2) then
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = iter.i2 + 1, effectLocations:Sequence(Integer) = iter.effectLocations}
              else
                if e = firstEffect then
                  Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 2, effectLocations:Sequence(Integer) = iter.effectLocations}
                else
                  Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 1, effectLocations:Sequence(Integer) = iter.effectLocations}
                endif
              endif
            else
              if iter.i2 > 1 and e = effects->at(iter.i2) then
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = iter.i2 + 1, effectLocations:Sequence(Integer) = iter.effectLocations}
              else
                if e = firstEffect then
                  Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 2, effectLocations:Sequence(Integer) = iter.effectLocations}
                else
                  Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectLocations:Sequence(Integer) = iter.effectLocations}
                endif
              endif
            endif
          endif
        endif
      endif
    else
      iter
    endif
  )
in
if result.effectLocations->notEmpty() then
  if result.effectLocations->first() < result.causeLocation then
    if result.effectLocations->last() < result.causeLocation then
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = Sequence{},
          effectLocations:Sequence(Integer) = result.effectLocations,
          violationType:ViolationType = ViolationType::NSOR
        }
      }
    else
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = Sequence{},
          effectLocations:Sequence(Integer) = result.effectLocations->select(effectLocation | effectLocation < result.causeLocation),
          violationType:ViolationType = ViolationType::NSOR
        },
        Tuple{
          causeLocations:Sequence(Integer) = Sequence{result.causeLocation},
          effectLocations:Sequence(Integer) = result.effectLocations->select(effectLocation | effectLocation > result.causeLocation),
          violationType:ViolationType = ViolationType::WTO
        }
      }
    endif
  else
    Sequence{
      Tuple{
        causeLocations:Sequence(Integer) = Sequence{result.causeLocation},
        effectLocations:Sequence(Integer) = result.effectLocations,
        violationType:ViolationType = ViolationType::WTO
      }
    }
  endif
else
  null
endif

-- modified on 03/09/2015
def: reportPatternPrecedenceManyManyAtMostMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), distance:Integer, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, causeLocation:Integer, midCriticalInstant:Integer, i1:Integer, i2:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, causeLocation:Integer, midCriticalInstant:Integer, i1:Integer, i2:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, causeLocation:Integer = 0, midCriticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      if iter.causeLocation > 0 then
        Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
      else
        Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}}
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.index, midCriticalInstant:Integer = elem.timestamp + distance, i1:Integer = 1, i2:Integer = 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 2, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = iter.i2 + 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 2, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = iter.i2 + 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 2, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        endif
      endif
    endif
  )
in
result.violations

-- modified on 04/09/2015
def: reportPatternPrecedenceManyManyExactlyMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), distance:Integer, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), i1:Integer, i2:Integer, rollbackInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), i1:Integer, i2:Integer, rollbackInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      if iter.candidates->notEmpty() then
        if iter.candidates.midCriticalInstant->excludes(iter.rollbackInstant) then
          let leftViolations:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer))= iter.candidates->select(midCriticalInstant < iter.rollbackInstant), rightViolations:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant) in
          if leftViolations->notEmpty() then
            if rightViolations->notEmpty() then--iter.effectLocations must be empty
              Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = rightViolations, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolations->last().causeLocation, rightViolations->first().causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
            else
              Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = leftViolations->subSequence(1, 1), i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolations->last().causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
            endif
          else
            Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = rightViolations, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{rightViolations->first().causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
          endif
        else
          Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->reject(midCriticalInstant < iter.rollbackInstant), i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        endif
      else
        Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}}
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + distance, causeLocation:Integer = iter.index}), i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if e = firstEffect then
              Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i1:Integer = iter.i1 + 1, i2:Integer = 2, rollbackInstant:Integer = elem.timestamp, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i1:Integer = iter.i1 + 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i1:Integer = 2, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if e = firstEffect then
              Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i1:Integer = 2, i2:Integer = 2, rollbackInstant:Integer = elem.timestamp, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i1:Integer = 2, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i1:Integer = 1, i2:Integer = iter.i2 + 1, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if e = firstEffect then
              Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i1:Integer = 1, i2:Integer = 2, rollbackInstant:Integer = elem.timestamp, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i1:Integer = 1, i2:Integer = 1, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        endif
      endif
    endif
  )
in
result.violations

--modified on 03/09/2015
def: reportPatternPrecedenceManyManyMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), distance:tempsy::TimeDistance, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let value:Integer = distance.value, which:tempsy::ComparingOperator=distance.comparingOperator in
if which = tempsy::ComparingOperator::ATLEAST then
  self.reportPatternPrecedenceManyManyAtLeastMid(trace, begin, end, causes, value, effects)
else
  if which = tempsy::ComparingOperator::ATMOST then
    self.reportPatternPrecedenceManyManyAtMostMid(trace, begin, end, causes, value, effects)
  else
    self.reportPatternPrecedenceManyManyExactlyMid(trace, begin, end, causes, value, effects)
  endif
endif

/******************************************
 * =reportPatternPrecedenceManyManyLeft
 ******************************************
*/

-- modified on 10/09/2015
def: reportPatternPrecedenceManyManyLeft(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  lastCauseDistanceType:Integer = causeDistances->last().which,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, flag:Boolean, i1:Integer, causeCriticalInstant:Integer, i2:Integer, wtcCauseLocation:Integer, notWTC:Boolean, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, flag:Boolean, i1:Integer, causeCriticalInstant:Integer, i2:Integer, wtcCauseLocation:Integer, notWTC:Boolean, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, flag:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, wtcCauseLocation:Integer = 0, notWTC:Boolean = true, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    if iter.flag then
      let e:String = elem.event in
      if iter.i2 = effectSize and e = lastEffect then
        if iter.wtcCauseLocation > 0 then
          Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = iter.notWTC, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.wtcCauseLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC})}
        else
          Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = iter.notWTC, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}}
        endif
      else
        if iter.i1 > 1 and e = causes->at(iter.i1) then
          if iter.i1 = causeSize then
            if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, lastCauseDistanceType) then
              Tuple{index:Integer = iter.index + 1, flag:Boolean = false, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = null, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, wtcCauseLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          else
            let i11:Integer = iter.i1 + 1 in
            if iter.i2 > 1 and e = effects->at(iter.i2) then
              if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = iter.i2 + 1, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = iter.notWTC, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
              else
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = iter.i2 + 1, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = false, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
              endif
            else
              if e = firstEffect then
                if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
                  Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = 2, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = iter.notWTC, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
                else
                  Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = 2, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = false, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
                endif
              else
                if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
                  Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = 1, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = iter.notWTC, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
                else
                  Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = 1, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = false, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
                endif
              endif
            endif
          endif
        else
          if e = firstCause then
            if iter.i2 > 1 and e = effects->at(iter.i2) then
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = iter.i2 + 1, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = true, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              if e = firstEffect then
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 2, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = true, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
              else
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = true, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
              endif
            endif
          else
            if iter.i2 > 1 and e = effects->at(iter.i2) then
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = true, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              if e = firstEffect then
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = true, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
              else
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = true, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
              endif
            endif
          endif
        endif
      endif
    else
      iter
    endif
  )
in
result.violations

-- modified on 10/09/2015
def: reportPatternPrecedenceManyManyLeftAtLeastMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  lastCauseDistanceType:Integer = causeDistances->last().which,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, flag:Boolean, causeLocation:Integer, midCriticalInstant:Integer, wtcCauseLocation:Integer, wtcMidCriticalInstant:Integer, notWTC:Boolean, isWTOC:Boolean, i1:Integer, causeCriticalInstant:Integer, i2:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, flag:Boolean, causeLocation:Integer, midCriticalInstant:Integer, wtcCauseLocation:Integer, wtcMidCriticalInstant:Integer, notWTC:Boolean, isWTOC:Boolean, i1:Integer, causeCriticalInstant:Integer, i2:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, flag:Boolean = true, causeLocation:Integer = 0, midCriticalInstant:Integer = 0, wtcCauseLocation:Integer = 0, wtcMidCriticalInstant:Integer = 0, notWTC:Boolean = true, isWTOC:Boolean = false, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    if iter.flag then
      if iter.midCriticalInstant > 0 and elem.timestamp > iter.midCriticalInstant and iter.i2 = 1 then
        Tuple{index:Integer = iter.index + 1, flag:Boolean = false, causeLocation:Integer = null, midCriticalInstant:Integer = null, wtcCauseLocation:Integer = null, wtcMidCriticalInstant:Integer = null, notWTC:Boolean = null, isWTOC:Boolean = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
      else
        let e:String = elem.event in
        if iter.i2 = effectSize and e = lastEffect then
          if iter.causeLocation = 0 and iter.wtcCauseLocation = 0 then--NSOR
            Tuple{
              index:Integer = iter.index + 1,
              flag:Boolean = iter.flag,
              causeLocation:Integer = iter.causeLocation,
              midCriticalInstant:Integer = iter.midCriticalInstant,
              wtcCauseLocation:Integer = iter.wtcCauseLocation,
              wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
              notWTC:Boolean = iter.notWTC,
              isWTOC:Boolean = iter.isWTOC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              i2:Integer = 1,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}
            }
          else
            if iter.wtcCauseLocation = 0 or (iter.causeLocation > 0 and iter.causeLocation < iter.wtcCauseLocation) then--WTO
              Tuple{
                index:Integer = iter.index + 1,
                flag:Boolean = iter.flag,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = iter.notWTC,
                isWTOC:Boolean = iter.isWTOC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                i2:Integer = 1,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
              }
            else
              if iter.isWTOC then--WTOC
                Tuple{
                  index:Integer = iter.index + 1,
                  flag:Boolean = iter.flag,
                  causeLocation:Integer = iter.causeLocation,
                  midCriticalInstant:Integer = iter.midCriticalInstant,
                  wtcCauseLocation:Integer = iter.wtcCauseLocation,
                  wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                  notWTC:Boolean = iter.notWTC,
                  isWTOC:Boolean = iter.isWTOC,
                  i1:Integer = 1,
                  causeCriticalInstant:Integer = iter.causeCriticalInstant,
                  i2:Integer = 1,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.wtcCauseLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTOC})
                }
              else
                if iter.causeLocation = 0 then--WTC
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.wtcCauseLocation,
                    wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                    notWTC:Boolean = iter.notWTC,
                    isWTOC:Boolean = iter.isWTOC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    i2:Integer = 1,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.wtcCauseLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC})
                  }
                else--LIRV
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.wtcCauseLocation,
                    wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                    notWTC:Boolean = iter.notWTC,
                    isWTOC:Boolean = iter.isWTOC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    i2:Integer = 1,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.wtcCauseLocation, iter.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::LIRV})
                  }
                endif
              endif
            endif
          endif
        else
          if iter.i1 > 1 and e = causes->at(iter.i1) then
            if iter.i1 = causeSize then
              if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, lastCauseDistanceType) then
                Tuple{
                  index:Integer = iter.index + 1,
                  flag:Boolean = iter.flag,
                  causeLocation:Integer = iter.index,
                  midCriticalInstant:Integer = elem.timestamp + midDistance,
                  wtcCauseLocation:Integer = iter.wtcCauseLocation,
                  wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                  notWTC:Boolean = iter.notWTC,
                  isWTOC:Boolean = iter.isWTOC,
                  i1:Integer = 1,
                  causeCriticalInstant:Integer = iter.causeCriticalInstant,
                  i2:Integer = 1,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                }
              else
                if iter.wtcCauseLocation > 0 then
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.wtcCauseLocation,
                    wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                    notWTC:Boolean = iter.notWTC,
                    isWTOC:Boolean = iter.isWTOC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    i2:Integer = 1,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                  }
                else
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.index,
                    wtcMidCriticalInstant:Integer = elem.timestamp + midDistance,
                    notWTC:Boolean = iter.notWTC,
                    isWTOC:Boolean = iter.isWTOC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    i2:Integer = 1,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                  }
                endif
              endif
            else
              let i11:Integer = iter.i1 + 1, nextCauseCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value in
              if iter.i2 > 1 and e = effects->at(iter.i2) then
                if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.wtcCauseLocation,
                    wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                    notWTC:Boolean = iter.notWTC,
                    isWTOC:Boolean = iter.isWTOC,
                    i1:Integer = i11,
                    causeCriticalInstant:Integer = nextCauseCriticalInstant,
                    i2:Integer = iter.i2 + 1,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                  }
                else
                  if iter.wtcCauseLocation > 0 then
                    Tuple{
                      index:Integer = iter.index + 1,
                      flag:Boolean = iter.flag,
                      causeLocation:Integer = iter.causeLocation,
                      midCriticalInstant:Integer = iter.midCriticalInstant,
                      wtcCauseLocation:Integer = iter.wtcCauseLocation,
                      wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                      notWTC:Boolean = iter.notWTC,
                      isWTOC:Boolean = iter.isWTOC,
                      i1:Integer = 1,
                      causeCriticalInstant:Integer = iter.causeCriticalInstant,
                      i2:Integer = iter.i2 + 1,
                      violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                    }
                  else
                    Tuple{
                      index:Integer = iter.index + 1,
                      flag:Boolean = iter.flag,
                      causeLocation:Integer = iter.causeLocation,
                      midCriticalInstant:Integer = iter.midCriticalInstant,
                      wtcCauseLocation:Integer = iter.wtcCauseLocation,
                      wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                      notWTC:Boolean = false,
                      isWTOC:Boolean = iter.isWTOC,
                      i1:Integer = i11,
                      causeCriticalInstant:Integer = nextCauseCriticalInstant,
                      i2:Integer = iter.i2 + 1,
                      violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                    }
                  endif
                endif
              else
                if e = firstEffect then
                  if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
                    Tuple{
                      index:Integer = iter.index + 1,
                      flag:Boolean = iter.flag,
                      causeLocation:Integer = iter.causeLocation,
                      midCriticalInstant:Integer = iter.midCriticalInstant,
                      wtcCauseLocation:Integer = iter.wtcCauseLocation,
                      wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                      notWTC:Boolean = iter.notWTC,
                      isWTOC:Boolean = elem.timestamp < iter.wtcMidCriticalInstant,
                      i1:Integer = i11,
                      causeCriticalInstant:Integer = nextCauseCriticalInstant,
                      i2:Integer = 2,
                      violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                    }
                  else
                    if iter.wtcCauseLocation > 0 then
                      Tuple{
                        index:Integer = iter.index + 1,
                        flag:Boolean = iter.flag,
                        causeLocation:Integer = iter.causeLocation,
                        midCriticalInstant:Integer = iter.midCriticalInstant,
                        wtcCauseLocation:Integer = iter.wtcCauseLocation,
                        wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                        notWTC:Boolean = iter.notWTC,
                        isWTOC:Boolean = elem.timestamp < iter.wtcMidCriticalInstant,
                        i1:Integer = 1,
                        causeCriticalInstant:Integer = iter.causeCriticalInstant,
                        i2:Integer = 2,
                        violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                      }
                    else
                      Tuple{
                        index:Integer = iter.index + 1,
                        flag:Boolean = iter.flag,
                        causeLocation:Integer = iter.causeLocation,
                        midCriticalInstant:Integer = iter.midCriticalInstant,
                        wtcCauseLocation:Integer = iter.wtcCauseLocation,
                        wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                        notWTC:Boolean = false,
                        isWTOC:Boolean = elem.timestamp < iter.wtcMidCriticalInstant,
                        i1:Integer = i11,
                        causeCriticalInstant:Integer = nextCauseCriticalInstant,
                        i2:Integer = 2,
                        violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                      }
                    endif
                  endif
                else
                  if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
                    Tuple{
                      index:Integer = iter.index + 1,
                      flag:Boolean = iter.flag,
                      causeLocation:Integer = iter.causeLocation,
                      midCriticalInstant:Integer = iter.midCriticalInstant,
                      wtcCauseLocation:Integer = iter.wtcCauseLocation,
                      wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                      notWTC:Boolean = iter.notWTC,
                      isWTOC:Boolean = iter.isWTOC,
                      i1:Integer = i11,
                      causeCriticalInstant:Integer = nextCauseCriticalInstant,
                      i2:Integer = 1,
                      violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                    }
                  else
                    if iter.wtcCauseLocation > 0 then
                      Tuple{
                        index:Integer = iter.index + 1,
                        flag:Boolean = iter.flag,
                        causeLocation:Integer = iter.causeLocation,
                        midCriticalInstant:Integer = iter.midCriticalInstant,
                        wtcCauseLocation:Integer = iter.wtcCauseLocation,
                        wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                        notWTC:Boolean = iter.notWTC,
                        isWTOC:Boolean = iter.isWTOC,
                        i1:Integer = 1,
                        causeCriticalInstant:Integer = iter.causeCriticalInstant,
                        i2:Integer = 1,
                        violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                      }
                    else
                      Tuple{
                        index:Integer = iter.index + 1,
                        flag:Boolean = iter.flag,
                        causeLocation:Integer = iter.causeLocation,
                        midCriticalInstant:Integer = iter.midCriticalInstant,
                        wtcCauseLocation:Integer = iter.wtcCauseLocation,
                        wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                        notWTC:Boolean = false,
                        isWTOC:Boolean = iter.isWTOC,
                        i1:Integer = i11,
                        causeCriticalInstant:Integer = nextCauseCriticalInstant,
                        i2:Integer = 1,
                        violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                      }
                    endif
                  endif
                endif
              endif
            endif
          else
            if iter.midCriticalInstant = 0 and e = firstCause then
              if iter.i2 > 1 and e = effects->at(iter.i2) then
                Tuple{
                  index:Integer = iter.index + 1,
                  flag:Boolean = iter.flag,
                  causeLocation:Integer = iter.causeLocation,
                  midCriticalInstant:Integer = iter.midCriticalInstant,
                  wtcCauseLocation:Integer = iter.wtcCauseLocation,
                  wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                  notWTC:Boolean = true,
                  isWTOC:Boolean = iter.isWTOC,
                  i1:Integer = 2,
                  causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
                  i2:Integer = iter.i2 + 1,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                }
              else
                if e = firstEffect then
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.wtcCauseLocation,
                    wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                    notWTC:Boolean = true,
                    isWTOC:Boolean = elem.timestamp < iter.wtcMidCriticalInstant,
                    i1:Integer = 2,
                    causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
                    i2:Integer = 2,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                  }
                else
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.wtcCauseLocation,
                    wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                    notWTC:Boolean = true,
                    isWTOC:Boolean = iter.isWTOC,
                    i1:Integer = 2,
                    causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
                    i2:Integer = 1,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                  }
                endif
              endif
            else
              if iter.i2 > 1 and e = effects->at(iter.i2) then
                Tuple{
                  index:Integer = iter.index + 1,
                  flag:Boolean = iter.flag,
                  causeLocation:Integer = iter.causeLocation,
                  midCriticalInstant:Integer = iter.midCriticalInstant,
                  wtcCauseLocation:Integer = iter.wtcCauseLocation,
                  wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                  notWTC:Boolean = iter.notWTC,
                  isWTOC:Boolean = iter.isWTOC,
                  i1:Integer = 1,
                  causeCriticalInstant:Integer = iter.causeCriticalInstant,
                  i2:Integer = iter.i2 + 1,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                }
              else
                if e = firstEffect then
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.wtcCauseLocation,
                    wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                    notWTC:Boolean = iter.notWTC,
                    isWTOC:Boolean = elem.timestamp < iter.wtcMidCriticalInstant,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    i2:Integer = 2,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                  }
                else
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.wtcCauseLocation,
                    wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                    notWTC:Boolean = iter.notWTC,
                    isWTOC:Boolean = iter.isWTOC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    i2:Integer = 1,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                  }
                endif
              endif
            endif
          endif
        endif
      endif
    else
      iter
    endif
  )
in
result.violations

-- modified on 10/09/2015
def: reportPatternPrecedenceManyManyLeftAtMostMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  lastCauseDistanceType:Integer = causeDistances->last().which,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, causeLocation:Integer, midCriticalInstant:Integer, wtcCauseLocation:Integer, wtcMidCriticalInstant:Integer, notWTC:Boolean, i1:Integer, causeCriticalInstant:Integer, i2:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, causeLocation:Integer, midCriticalInstant:Integer, wtcCauseLocation:Integer, wtcMidCriticalInstant:Integer, notWTC:Boolean, isWTOC:Boolean, i1:Integer, causeCriticalInstant:Integer, i2:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, causeLocation:Integer = 0, midCriticalInstant:Integer = 0, wtcCauseLocation:Integer = 0, wtcMidCriticalInstant:Integer = 0, notWTC:Boolean = true, isWTOC:Boolean = false, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then--the possibility of violation has been checked when e = firstEffect with the condition of elem.timestamp > iter.midCriticalInstant 
      if iter.causeLocation = 0 and iter.wtcCauseLocation = 0 then
        Tuple{
          index:Integer = iter.index + 1,
          causeLocation:Integer = iter.causeLocation,
          midCriticalInstant:Integer = iter.midCriticalInstant,
          wtcCauseLocation:Integer = iter.wtcCauseLocation,
          wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
          notWTC:Boolean = iter.notWTC,
          isWTOC:Boolean = iter.isWTOC,
          i1:Integer = 1,
          causeCriticalInstant:Integer = iter.causeCriticalInstant,
          i2:Integer = 1,
          violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}
        }
      else
        if iter.wtcCauseLocation < iter.causeLocation then
          Tuple{
            index:Integer = iter.index + 1,
            causeLocation:Integer = iter.causeLocation,
            midCriticalInstant:Integer = iter.midCriticalInstant,
            wtcCauseLocation:Integer = iter.wtcCauseLocation,
            wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
            notWTC:Boolean = iter.notWTC,
            isWTOC:Boolean = iter.isWTOC,
            i1:Integer = 1,
            causeCriticalInstant:Integer = iter.causeCriticalInstant,
            i2:Integer = 1,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
          }
        else
          if iter.isWTOC then
            Tuple{
              index:Integer = iter.index + 1,
              causeLocation:Integer = iter.causeLocation,
              midCriticalInstant:Integer = iter.midCriticalInstant,
              wtcCauseLocation:Integer = iter.wtcCauseLocation,
              wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
              notWTC:Boolean = iter.notWTC,
              isWTOC:Boolean = iter.isWTOC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              i2:Integer = 1,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.wtcCauseLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTOC})
            }
          else
            if iter.causeLocation = 0 then
              Tuple{
                index:Integer = iter.index + 1,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = iter.notWTC,
                isWTOC:Boolean = iter.isWTOC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                i2:Integer = 1,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.wtcCauseLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC})
              }
            else--LVRI
              Tuple{
                index:Integer = iter.index + 1,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = iter.notWTC,
                isWTOC:Boolean = iter.isWTOC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                i2:Integer = 1,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.causeLocation, iter.wtcCauseLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::LVRI})
              }
            endif
          endif
        endif
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, lastCauseDistanceType) then
            Tuple{
              index:Integer = iter.index + 1,
              causeLocation:Integer = iter.index,
              midCriticalInstant:Integer = elem.timestamp + midDistance,
              wtcCauseLocation:Integer = iter.wtcCauseLocation,
              wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
              notWTC:Boolean = iter.notWTC,
              isWTOC:Boolean = iter.isWTOC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              i2:Integer = 1,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          else
            Tuple{
              index:Integer = iter.index + 1,
              causeLocation:Integer = iter.causeLocation,
              midCriticalInstant:Integer = iter.midCriticalInstant,
              wtcCauseLocation:Integer = iter.index,
              wtcMidCriticalInstant:Integer = elem.timestamp + midDistance,
              notWTC:Boolean = iter.notWTC,
              isWTOC:Boolean = iter.isWTOC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              i2:Integer = 1,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          endif
        else
          let i11:Integer = iter.i1 + 1, nextCauseCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, flagWTC:Boolean = iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) in
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{
              index:Integer = iter.index + 1,
              causeLocation:Integer = iter.causeLocation,
              midCriticalInstant:Integer = iter.midCriticalInstant,
              wtcCauseLocation:Integer = iter.wtcCauseLocation,
              wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
              notWTC:Boolean = flagWTC,
              isWTOC:Boolean = iter.isWTOC,
              i1:Integer = i11,
              causeCriticalInstant:Integer = nextCauseCriticalInstant,
              i2:Integer = iter.i2 + 1,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{
                index:Integer = iter.index + 1,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = iter.notWTC,
                isWTOC:Boolean = iter.wtcMidCriticalInstant > 0 and elem.timestamp > iter.wtcMidCriticalInstant,
                i1:Integer = i11,
                causeCriticalInstant:Integer = nextCauseCriticalInstant,
                i2:Integer = 2,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            else
              Tuple{
                index:Integer = iter.index + 1,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = iter.notWTC,
                isWTOC:Boolean = iter.isWTOC,
                i1:Integer = i11,
                causeCriticalInstant:Integer = nextCauseCriticalInstant,
                i2:Integer = 1,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{
              index:Integer = iter.index + 1,
              causeLocation:Integer = iter.causeLocation,
              midCriticalInstant:Integer = iter.midCriticalInstant,
              wtcCauseLocation:Integer = iter.wtcCauseLocation,
              wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
              notWTC:Boolean = true,
              isWTOC:Boolean = iter.isWTOC,
              i1:Integer = 2,
              causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
              i2:Integer = iter.i2 + 1,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{
                index:Integer = iter.index + 1,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = true,
                isWTOC:Boolean = iter.wtcMidCriticalInstant > 0 and elem.timestamp > iter.wtcMidCriticalInstant,
                i1:Integer = 2,
                causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
                i2:Integer = 2,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            else
              Tuple{
                index:Integer = iter.index + 1,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = true,
                isWTOC:Boolean = iter.isWTOC,
                i1:Integer = 2,
                causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
                i2:Integer = 1,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{
              index:Integer = iter.index + 1,
              causeLocation:Integer = iter.causeLocation,
              midCriticalInstant:Integer = iter.midCriticalInstant,
              wtcCauseLocation:Integer = iter.wtcCauseLocation,
              wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
              notWTC:Boolean = iter.notWTC,
              isWTOC:Boolean = iter.isWTOC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              i2:Integer = iter.i2 + 1,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{
                index:Integer = iter.index + 1,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = iter.notWTC,
                isWTOC:Boolean = iter.wtcMidCriticalInstant > 0 and elem.timestamp > iter.wtcMidCriticalInstant,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                i2:Integer = 2,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            else
              Tuple{
                index:Integer = iter.index + 1,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = iter.notWTC,
                isWTOC:Boolean = iter.isWTOC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                i2:Integer = 1,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            endif
          endif
        endif
      endif
    endif
  )
in
result.violations

-- modified on 10/09/2015
def: reportPatternPrecedenceManyManyLeftExactlyMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  lastCauseDistanceType:Integer = causeDistances->last().which,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)), notWTC:Boolean, i1:Integer, causeCriticalInstant:Integer, i2:Integer, rollbackInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)), notWTC:Boolean, i1:Integer, causeCriticalInstant:Integer, i2:Integer, rollbackInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = Sequence{}, notWTC:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, rollbackInstant:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      if iter.candidates->notEmpty() then
        if iter.candidates.midCriticalInstant->excludes(iter.rollbackInstant) then
          let leftViolations:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates->select(midCriticalInstant < iter.rollbackInstant), rightViolations:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant) in
          if leftViolations->notEmpty() then
            let leftViolation:Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean) = leftViolations->last() in
            if rightViolations->notEmpty() then
              let rightViolation:Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean) = rightViolations->first() in
              if leftViolation.notWTC then
                if rightViolation.notWTC then
                  Tuple{
                    index:Integer = iter.index + 1,
                    candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = rightViolations,
                    notWTC:Boolean = iter.notWTC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    i2:Integer = 1,
                    rollbackInstant:Integer = iter.rollbackInstant,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolation.causeLocation, rightViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
                  }
                else
                  Tuple{
                    index:Integer = iter.index + 1,
                    candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = rightViolations,
                    notWTC:Boolean = iter.notWTC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    i2:Integer = 1,
                    rollbackInstant:Integer = iter.rollbackInstant,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolation.causeLocation, rightViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::LVRI})
                  }
                endif
              else
                if rightViolation.notWTC then
                  Tuple{
                    index:Integer = iter.index + 1,
                    candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = rightViolations,
                    notWTC:Boolean = iter.notWTC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    i2:Integer = 1,
                    rollbackInstant:Integer = iter.rollbackInstant,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolation.causeLocation, rightViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::LIRV})
                  }
                else
                  Tuple{
                    index:Integer = iter.index + 1,
                    candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = rightViolations,
                    notWTC:Boolean = iter.notWTC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    i2:Integer = 1,
                    rollbackInstant:Integer = iter.rollbackInstant,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolation.causeLocation, rightViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::LIRI})
                  }
                endif
              endif
            else
              if leftViolation.notWTC then
                Tuple{
                  index:Integer = iter.index + 1,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = Sequence{leftViolation},
                  notWTC:Boolean = iter.notWTC,
                  i1:Integer = 1,
                  causeCriticalInstant:Integer = iter.causeCriticalInstant,
                  i2:Integer = 1,
                  rollbackInstant:Integer = iter.rollbackInstant,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
                }
              else
                Tuple{
                  index:Integer = iter.index + 1,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = Sequence{leftViolation},
                  notWTC:Boolean = iter.notWTC,
                  i1:Integer = 1,
                  causeCriticalInstant:Integer = iter.causeCriticalInstant,
                  i2:Integer = 1,
                  rollbackInstant:Integer = iter.rollbackInstant,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTOC})
                }
              endif
            endif
          else--if rightViolations->notEmpty() then
            let rightViolation:Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean) = rightViolations->first() in
            if rightViolation.notWTC then
              Tuple{
                index:Integer = iter.index + 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = rightViolations,
                notWTC:Boolean = iter.notWTC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                i2:Integer = 1,
                rollbackInstant:Integer = iter.rollbackInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{rightViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
              }
            else
              Tuple{
                index:Integer = iter.index + 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = rightViolations,
                notWTC:Boolean = iter.notWTC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                i2:Integer = 1,
                rollbackInstant:Integer = iter.rollbackInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{rightViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTOC})
              }
            endif
          endif
        else
          let violation:Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean) = iter.candidates->select(midCriticalInstant = iter.rollbackInstant)->first() in
          if not violation.notWTC then
            Tuple{
              index:Integer = iter.index + 1,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates->reject(midCriticalInstant < iter.rollbackInstant),
              notWTC:Boolean = iter.notWTC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              i2:Integer = 1,
              rollbackInstant:Integer = iter.rollbackInstant,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{violation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC})
            }
          else
            Tuple{
              index:Integer = iter.index + 1,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates->reject(midCriticalInstant < iter.rollbackInstant),
              notWTC:Boolean = iter.notWTC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              i2:Integer = 1,
              rollbackInstant:Integer = iter.rollbackInstant,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          endif
        endif
      else
        Tuple{
          index:Integer = iter.index + 1,
          candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
          notWTC:Boolean = iter.notWTC,
          i1:Integer = 1,
          causeCriticalInstant:Integer = iter.causeCriticalInstant,
          i2:Integer = 1,
          rollbackInstant:Integer = iter.rollbackInstant,
          violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}
        }
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, lastCauseDistanceType) then
            Tuple{
              index:Integer = iter.index + 1,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}),
              notWTC:Boolean = iter.notWTC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              i2:Integer = 1,
              rollbackInstant:Integer = iter.rollbackInstant,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          else
            Tuple{
              index:Integer = iter.index + 1,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index, notWTC:Boolean = false}),
              notWTC:Boolean = iter.notWTC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              i2:Integer = 1,
              rollbackInstant:Integer = iter.rollbackInstant,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          endif
        else
          let i11:Integer = iter.i1 + 1, nextCauseCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value in
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
              Tuple{
                index:Integer = iter.index + 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
                notWTC:Boolean = iter.notWTC,
                i1:Integer = i11,
                causeCriticalInstant:Integer = nextCauseCriticalInstant,
                i2:Integer = iter.i2 + 1,
                rollbackInstant:Integer = iter.rollbackInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            else
              Tuple{
                index:Integer = iter.index + 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
                notWTC:Boolean = false,
                i1:Integer = i11,
                causeCriticalInstant:Integer = nextCauseCriticalInstant,
                i2:Integer = iter.i2 + 1,
                rollbackInstant:Integer = iter.rollbackInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            endif
          else
            if e = firstEffect then
              if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
                Tuple{
                  index:Integer = iter.index + 1,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
                  notWTC:Boolean = iter.notWTC,
                  i1:Integer = i11,
                  causeCriticalInstant:Integer = nextCauseCriticalInstant,
                  i2:Integer = 2,
                  rollbackInstant:Integer = elem.timestamp,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                }
              else
                Tuple{
                  index:Integer = iter.index + 1,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
                  notWTC:Boolean = false,
                  i1:Integer = i11,
                  causeCriticalInstant:Integer = nextCauseCriticalInstant,
                  i2:Integer = 2,
                  rollbackInstant:Integer = elem.timestamp,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                }
              endif
            else
              if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
                Tuple{
                  index:Integer = iter.index + 1,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
                  notWTC:Boolean = iter.notWTC,
                  i1:Integer = i11,
                  causeCriticalInstant:Integer = nextCauseCriticalInstant,
                  i2:Integer = 1,
                  rollbackInstant:Integer = iter.rollbackInstant,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                }
              else
                Tuple{
                  index:Integer = iter.index + 1,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
                  notWTC:Boolean = false,
                  i1:Integer = i11,
                  causeCriticalInstant:Integer = nextCauseCriticalInstant,
                  i2:Integer = 1,
                  rollbackInstant:Integer = iter.rollbackInstant,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                }
              endif
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{
              index:Integer = iter.index + 1,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
              notWTC:Boolean = true,
              i1:Integer = 2,
              causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
              i2:Integer = iter.i2 + 1,
              rollbackInstant:Integer = iter.rollbackInstant,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          else
            if e = firstEffect then
              Tuple{
                index:Integer = iter.index + 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
                notWTC:Boolean = true,
                i1:Integer = 2,
                causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
                i2:Integer = 2,
                rollbackInstant:Integer = elem.timestamp,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            else
              Tuple{
                index:Integer = iter.index + 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
                notWTC:Boolean = true,
                i1:Integer = 2,
                causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
                i2:Integer = 1,
                rollbackInstant:Integer = iter.rollbackInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{
              index:Integer = iter.index + 1,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
              notWTC:Boolean = iter.notWTC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              i2:Integer = iter.i2 + 1,
              rollbackInstant:Integer = iter.rollbackInstant,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          else
            if e = firstEffect then
              Tuple{
                index:Integer = iter.index + 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
                notWTC:Boolean = iter.notWTC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                i2:Integer = 2,
                rollbackInstant:Integer = elem.timestamp,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            else
              Tuple{
                index:Integer = iter.index + 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
                notWTC:Boolean = iter.notWTC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                i2:Integer = 1,
                rollbackInstant:Integer = iter.rollbackInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            endif
          endif
        endif
      endif
    endif
  )
in
result.violations

--modified on 04/09/2015
def: reportPatternPrecedenceManyManyLeftMid(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:tempsy::TimeDistance, effects:Sequence(String)): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let midValue:Integer = midDistance.value, midWhich:tempsy::ComparingOperator=midDistance.comparingOperator in
if midWhich = tempsy::ComparingOperator::ATLEAST then
  self.reportPatternPrecedenceManyManyLeftAtLeastMid(trace, begin, end, causes, causeDistances, midValue, effects)
else
  if midWhich = tempsy::ComparingOperator::ATMOST then
    self.reportPatternPrecedenceManyManyLeftAtMostMid(trace, begin, end, causes, causeDistances, midValue, effects)
  else
    self.reportPatternPrecedenceManyManyLeftExactlyMid(trace, begin, end, causes, causeDistances, midValue, effects)
  endif
endif

/******************************************
 * =reportPatternPrecedenceManyManyRight
 ******************************************
*/

-- modified on 04/09/2015
def: reportPatternPrecedenceManyManyRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, flag:Boolean, i1:Integer, i2:Integer, effectCriticalInstant:Integer, effectLocations:Sequence(Integer)) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, flag:Boolean, i1:Integer, i2:Integer, effectCriticalInstant:Integer, effectLocations:Sequence(Integer))
    = Tuple{index:Integer = begin, flag:Boolean = true, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0, effectLocations:Sequence(Integer) = Sequence{}}
    |
    if iter.flag then
      let e:String = elem.event in
      if iter.i2 = effectSize and e = lastEffect then
        Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, effectLocations:Sequence(Integer) = iter.effectLocations->append(iter.index)}
      else
        if iter.i1 > 1 and e = causes->at(iter.i1) then
          if iter.i1 = causeSize then
            Tuple{index:Integer = iter.index + 1, flag:Boolean = false, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null, effectLocations:Sequence(Integer) = iter.effectLocations}
          else
            if iter.i2 > 1 and e = effects->at(iter.i2) then
              let i22:Integer = iter.i2 + 1 in
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = iter.i1 + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, effectLocations:Sequence(Integer) = iter.effectLocations}
            else
              if e = firstEffect then
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, effectLocations:Sequence(Integer) = iter.effectLocations}
              else
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, effectLocations:Sequence(Integer) = iter.effectLocations}
              endif
            endif
          endif
        else
          if e = firstCause then
            if iter.i2 > 1 and e = effects->at(iter.i2) then
              let i22:Integer = iter.i2 + 1 in
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 2, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, effectLocations:Sequence(Integer) = iter.effectLocations}
            else
              if e = firstEffect then
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 2, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, effectLocations:Sequence(Integer) = iter.effectLocations}
              else
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 2, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, effectLocations:Sequence(Integer) = iter.effectLocations}
              endif
            endif
          else
            if iter.i2 > 1 and e = effects->at(iter.i2) then
              let i22:Integer = iter.i2 + 1 in
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, effectLocations:Sequence(Integer) = iter.effectLocations}
            else
              if e = firstEffect then
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, effectLocations:Sequence(Integer) = iter.effectLocations}
              else
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, effectLocations:Sequence(Integer) = iter.effectLocations}
              endif
            endif
          endif
        endif
      endif
    else
      iter
    endif
  )
in
if result.effectLocations->notEmpty() then
  Sequence{
    Tuple{
      causeLocations:Sequence(Integer) = Sequence{},
      effectLocations:Sequence(Integer) = result.effectLocations,
      violationType:ViolationType = ViolationType::NSOR
    }
  }
else
  null
endif

-- modified on 04/09/2015
def: reportPatternPrecedenceManyManyAtLeastMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, flag:Boolean, causeLocation:Integer, midCriticalInstant:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer, effectLocations:Sequence(Integer)) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, flag:Boolean, causeLocation:Integer, midCriticalInstant:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer, effectLocations:Sequence(Integer))
    = Tuple{index:Integer = begin, flag:Boolean = true, causeLocation:Integer = 0, midCriticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0, effectLocations:Sequence(Integer) = Sequence{}} |
    if iter.flag then
      if iter.midCriticalInstant > 0 and elem.timestamp > iter.midCriticalInstant and iter.i2 = 1 then
        Tuple{index:Integer = iter.index + 1, flag:Boolean = false, causeLocation:Integer = null, midCriticalInstant:Integer = null, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null, effectLocations:Sequence(Integer) = iter.effectLocations}
      else
        let e:String = elem.event in
        if iter.i2 = effectSize and e = lastEffect then
          Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, effectLocations:Sequence(Integer) = iter.effectLocations->append(iter.index)}
        else
          if iter.i1 > 1 and e = causes->at(iter.i1) then
            if iter.i1 = causeSize then
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.index, midCriticalInstant:Integer = elem.timestamp + midDistance, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, effectLocations:Sequence(Integer) = iter.effectLocations}
            else
              if iter.i2 > 1 and e = effects->at(iter.i2) then
                let i22:Integer = iter.i2 + 1 in
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, effectLocations:Sequence(Integer) = iter.effectLocations}
              else
                if e = firstEffect then
                  Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, effectLocations:Sequence(Integer) = iter.effectLocations}
                else
                  Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, effectLocations:Sequence(Integer) = iter.effectLocations}
                endif
              endif
            endif
          else
            if iter.midCriticalInstant = 0 and e = firstCause then
              if iter.i2 > 1 and e = effects->at(iter.i2) then
                let i22:Integer = iter.i2 + 1 in
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, effectLocations:Sequence(Integer) = iter.effectLocations}
              else
                if e = firstEffect then
                  Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, effectLocations:Sequence(Integer) = iter.effectLocations}
                else
                  Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, effectLocations:Sequence(Integer) = iter.effectLocations}
                endif
              endif
            else
              if iter.i2 > 1 and e = effects->at(iter.i2) then
                let i22:Integer = iter.i2 + 1 in
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, effectLocations:Sequence(Integer) = iter.effectLocations}
              else
                if e = firstEffect then
                  Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, effectLocations:Sequence(Integer) = iter.effectLocations}
                else
                  Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, effectLocations:Sequence(Integer) = iter.effectLocations}
                endif
              endif
            endif
          endif
        endif
      endif
    else
      iter
    endif
  )
in
if result.effectLocations->notEmpty() then
  if result.effectLocations->first() < result.causeLocation then
    if result.effectLocations->last() < result.causeLocation then
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = Sequence{},
          effectLocations:Sequence(Integer) = result.effectLocations,
          violationType:ViolationType = ViolationType::NSOR
        }
      }
    else
      Sequence{
        Tuple{
          causeLocations:Sequence(Integer) = Sequence{},
          effectLocations:Sequence(Integer) = result.effectLocations->select(effectLocation | effectLocation < result.causeLocation),
          violationType:ViolationType = ViolationType::NSOR
        },
        Tuple{
          causeLocations:Sequence(Integer) = Sequence{result.causeLocation},
          effectLocations:Sequence(Integer) = result.effectLocations->select(effectLocation | effectLocation > result.causeLocation),
          violationType:ViolationType = ViolationType::WTO
        }
      }
    endif
  else
    Sequence{
      Tuple{
        causeLocations:Sequence(Integer) = Sequence{result.causeLocation},
        effectLocations:Sequence(Integer) = result.effectLocations,
        violationType:ViolationType = ViolationType::WTO
      }
    }
  endif
else
  null
endif

-- modified on 04/09/2015
def: reportPatternPrecedenceManyManyAtMostMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, causeLocation:Integer, midCriticalInstant:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, causeLocation:Integer, midCriticalInstant:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, causeLocation:Integer = 0, midCriticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      if iter.causeLocation > 0 then
        Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
      else
        Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}}
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.index, midCriticalInstant:Integer = elem.timestamp + midDistance, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, causeLocation:Integer = iter.causeLocation, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        endif
      endif
    endif
  )
in
result.violations

-- modified on 04/09/2015
def: reportPatternPrecedenceManyManyExactlyMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  lastEffect:String = effects->last(),
  result:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), i1:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)), i1:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = Sequence{}, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0, rollbackInstant:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      if iter.candidates->notEmpty() then
        if iter.candidates.midCriticalInstant->excludes(iter.rollbackInstant) then
          let leftViolations:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer))= iter.candidates->select(midCriticalInstant < iter.rollbackInstant), rightViolations:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant) in
          if leftViolations->notEmpty() then
            if rightViolations->notEmpty() then--iter.effectLocations must be empty
              Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = rightViolations, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolations->last().causeLocation, rightViolations->first().causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
            else
              Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = leftViolations->subSequence(1, 1), i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolations->last().causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
            endif
          else
            Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = rightViolations, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{rightViolations->first().causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})}
          endif
        else
          Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->reject(midCriticalInstant < iter.rollbackInstant), i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        endif
      else
        Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}}
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index}), i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i1:Integer = iter.i1 + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if e = firstEffect then
              Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, rollbackInstant:Integer = elem.timestamp, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i1:Integer = 2, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if e = firstEffect then
              Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i1:Integer = 2, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, rollbackInstant:Integer = elem.timestamp, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i1:Integer = 2, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i1:Integer = 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
          else
            if e = firstEffect then
              Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, rollbackInstant:Integer = elem.timestamp, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer)) = iter.candidates, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, rollbackInstant:Integer = iter.rollbackInstant, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          endif
        endif
      endif
    endif
  )
in
result.violations

--modified on 04/09/2015
def: reportPatternPrecedenceManyManyMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), midDistance:tempsy::TimeDistance, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let midValue:Integer = midDistance.value, midWhich:tempsy::ComparingOperator=midDistance.comparingOperator in
if midWhich = tempsy::ComparingOperator::ATLEAST then
  self.reportPatternPrecedenceManyManyAtLeastMidRight(trace, begin, end, causes, midValue, effects, effectDistances)
else
  if midWhich = tempsy::ComparingOperator::ATMOST then
    self.reportPatternPrecedenceManyManyAtMostMidRight(trace, begin, end, causes, midValue, effects, effectDistances)
  else
    self.reportPatternPrecedenceManyManyExactlyMidRight(trace, begin, end, causes, midValue, effects, effectDistances)
  endif
endif

/******************************************
 * =reportPatternPrecedenceManyManyLeftRight
 ******************************************
*/

-- modified on 10/09/2015
def: reportPatternPrecedenceManyManyLeftRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  lastCauseDistanceType:Integer = causeDistances->last().which,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  lastEffectDistanceType:Integer = effectDistances->last().which,
  result:Tuple(index:Integer, flag:Boolean, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer, wtcCauseLocation:Integer, notWTC:Boolean, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, flag:Boolean, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer, wtcCauseLocation:Integer, notWTC:Boolean, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, flag:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0, wtcCauseLocation:Integer = 0, notWTC:Boolean = true, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    if iter.flag then
      let e:String = elem.event in
      if iter.i2 = effectSize and e = lastEffect and self.compare(elem.timestamp, iter.effectCriticalInstant, lastEffectDistanceType) then
        if iter.wtcCauseLocation > 0 then
          Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = iter.notWTC, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.wtcCauseLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC})}
        else
          Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = iter.notWTC, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}}
        endif
      else
        if iter.i1 > 1 and e = causes->at(iter.i1) then
          if iter.i1 = causeSize then
            if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, lastCauseDistanceType) then
              Tuple{index:Integer = iter.index + 1, flag:Boolean = false, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = null, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, wtcCauseLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            endif
          else
            let i11:Integer = iter.i1 + 1 in
            if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              let i22:Integer = iter.i2 + 1 in
              if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = iter.notWTC, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
              else
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = false, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
              endif
            else
              if e = firstEffect then
                if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
                  Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = iter.notWTC, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
                else
                  Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = false, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
                endif
              else
                if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
                  Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = iter.notWTC, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
                else
                  Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = false, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
                endif
              endif
            endif
          endif
        else
          if e = firstCause then
            let i22:Integer = iter.i2 + 1 in
            if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = true, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              if e = firstEffect then
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = true, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
              else
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = true, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
              endif
            endif
          else
            let i22:Integer = iter.i2 + 1 in
            if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = true, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
            else
              if e = firstEffect then
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = true, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
              else
                Tuple{index:Integer = iter.index + 1, flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant, wtcCauseLocation:Integer = iter.wtcCauseLocation, notWTC:Boolean = true, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
              endif
            endif
          endif
        endif
      endif
    else
      iter
    endif
  )
in
result.violations

-- modified on 10/09/2015
def: reportPatternPrecedenceManyManyLeftAtLeastMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  lastCauseDistanceType:Integer = causeDistances->last().which,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  lastEffectDistanceType:Integer = effectDistances->last().which,
  result:Tuple(index:Integer, flag:Boolean, causeLocation:Integer, midCriticalInstant:Integer, wtcCauseLocation:Integer, wtcMidCriticalInstant:Integer, notWTC:Boolean, isWTOC:Boolean, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, flag:Boolean, causeLocation:Integer, midCriticalInstant:Integer, wtcCauseLocation:Integer, wtcMidCriticalInstant:Integer, notWTC:Boolean, isWTOC:Boolean, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, flag:Boolean = true, causeLocation:Integer = 0, midCriticalInstant:Integer = 0, wtcCauseLocation:Integer = 0, wtcMidCriticalInstant:Integer = 0, notWTC:Boolean = true, isWTOC:Boolean = false, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    if iter.flag then
      if iter.midCriticalInstant > 0 and elem.timestamp > iter.midCriticalInstant and iter.i2 = 1 then
        Tuple{index:Integer = iter.index + 1, flag:Boolean = false, causeLocation:Integer = null, midCriticalInstant:Integer = null, wtcCauseLocation:Integer = null, wtcMidCriticalInstant:Integer = null, notWTC:Boolean = null, isWTOC:Boolean = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations}
      else
        let e:String = elem.event in
        if iter.i2 = effectSize and e = lastEffect and self.compare(elem.timestamp, iter.effectCriticalInstant, lastEffectDistanceType) then
          if iter.causeLocation = 0 and iter.wtcCauseLocation = 0 then--NSOR
            Tuple{
              index:Integer = iter.index + 1,
              flag:Boolean = iter.flag,
              causeLocation:Integer = iter.causeLocation,
              midCriticalInstant:Integer = iter.midCriticalInstant,
              wtcCauseLocation:Integer = iter.wtcCauseLocation,
              wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
              notWTC:Boolean = iter.notWTC,
              isWTOC:Boolean = iter.isWTOC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              i2:Integer = 1,
              effectCriticalInstant:Integer = iter.effectCriticalInstant,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}
            }
          else
            if iter.wtcCauseLocation = 0 or (iter.causeLocation > 0 and iter.causeLocation < iter.wtcCauseLocation) then--WTO
              Tuple{
                index:Integer = iter.index + 1,
                flag:Boolean = iter.flag,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = iter.notWTC,
                isWTOC:Boolean = iter.isWTOC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                i2:Integer = 1,
                effectCriticalInstant:Integer = iter.effectCriticalInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
              }
            else
              if iter.isWTOC then--WTOC
                Tuple{
                  index:Integer = iter.index + 1,
                  flag:Boolean = iter.flag,
                  causeLocation:Integer = iter.causeLocation,
                  midCriticalInstant:Integer = iter.midCriticalInstant,
                  wtcCauseLocation:Integer = iter.wtcCauseLocation,
                  wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                  notWTC:Boolean = iter.notWTC,
                  isWTOC:Boolean = iter.isWTOC,
                  i1:Integer = 1,
                  causeCriticalInstant:Integer = iter.causeCriticalInstant,
                  i2:Integer = 1,
                  effectCriticalInstant:Integer = iter.effectCriticalInstant,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.wtcCauseLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTOC})
                }
              else
                if iter.causeLocation = 0 then
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.wtcCauseLocation,
                    wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                    notWTC:Boolean = iter.notWTC,
                    isWTOC:Boolean = iter.isWTOC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    i2:Integer = 1,
                    effectCriticalInstant:Integer = iter.effectCriticalInstant,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.wtcCauseLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC})
                  }
                else--LIRV
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.wtcCauseLocation,
                    wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                    notWTC:Boolean = iter.notWTC,
                    isWTOC:Boolean = iter.isWTOC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    i2:Integer = 1,
                    effectCriticalInstant:Integer = iter.effectCriticalInstant,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.wtcCauseLocation, iter.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::LIRV})
                  }
                endif
              endif
            endif
          endif
        else
          if iter.i1 > 1 and e = causes->at(iter.i1) then
            if iter.i1 = causeSize then
              if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, lastCauseDistanceType) then
                Tuple{
                  index:Integer = iter.index + 1,
                  flag:Boolean = iter.flag,
                  causeLocation:Integer = iter.index,
                  midCriticalInstant:Integer = elem.timestamp + midDistance,
                  wtcCauseLocation:Integer = iter.wtcCauseLocation,
                  wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                  notWTC:Boolean = iter.notWTC,
                  isWTOC:Boolean = iter.isWTOC,
                  i1:Integer = 1,
                  causeCriticalInstant:Integer = iter.causeCriticalInstant,
                  i2:Integer = 1,
                  effectCriticalInstant:Integer = iter.effectCriticalInstant,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                }
              else
                if iter.wtcCauseLocation > 0 then
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.wtcCauseLocation,
                    wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                    notWTC:Boolean = iter.notWTC,
                    isWTOC:Boolean = iter.isWTOC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    i2:Integer = 1,
                    effectCriticalInstant:Integer = iter.effectCriticalInstant,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                  }
                else
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.index,
                    wtcMidCriticalInstant:Integer = elem.timestamp + midDistance,
                    notWTC:Boolean = iter.notWTC,
                    isWTOC:Boolean = iter.isWTOC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    i2:Integer = 1,
                    effectCriticalInstant:Integer = iter.effectCriticalInstant,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                  }
                endif
              endif
            else
              let i11:Integer = iter.i1 + 1, nextCauseCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value in
              if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
                let i22:Integer = iter.i2 + 1 in
                if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.wtcCauseLocation,
                    wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                    notWTC:Boolean = iter.notWTC,
                    isWTOC:Boolean = iter.isWTOC,
                    i1:Integer = i11,
                    causeCriticalInstant:Integer = nextCauseCriticalInstant,
                    i2:Integer = i22,
                    effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                  }
                else
                  if iter.wtcCauseLocation > 0 then
                    Tuple{
                      index:Integer = iter.index + 1,
                      flag:Boolean = iter.flag,
                      causeLocation:Integer = iter.causeLocation,
                      midCriticalInstant:Integer = iter.midCriticalInstant,
                      wtcCauseLocation:Integer = iter.wtcCauseLocation,
                      wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                      notWTC:Boolean = iter.notWTC,
                      isWTOC:Boolean = iter.isWTOC,
                      i1:Integer = 1,
                      causeCriticalInstant:Integer = iter.causeCriticalInstant,
                      i2:Integer = i22,
                      effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value,
                      violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                    }
                  else
                    Tuple{
                      index:Integer = iter.index + 1,
                      flag:Boolean = iter.flag,
                      causeLocation:Integer = iter.causeLocation,
                      midCriticalInstant:Integer = iter.midCriticalInstant,
                      wtcCauseLocation:Integer = iter.wtcCauseLocation,
                      wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                      notWTC:Boolean = false,
                      isWTOC:Boolean = iter.isWTOC,
                      i1:Integer = i11,
                      causeCriticalInstant:Integer = nextCauseCriticalInstant,
                      i2:Integer = i22,
                      effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value,
                      violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                    }
                  endif
                endif
              else
                if e = firstEffect then
                  if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
                    Tuple{
                      index:Integer = iter.index + 1,
                      flag:Boolean = iter.flag,
                      causeLocation:Integer = iter.causeLocation,
                      midCriticalInstant:Integer = iter.midCriticalInstant,
                      wtcCauseLocation:Integer = iter.wtcCauseLocation,
                      wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                      notWTC:Boolean = iter.notWTC,
                      isWTOC:Boolean = elem.timestamp < iter.wtcMidCriticalInstant,
                      i1:Integer = i11,
                      causeCriticalInstant:Integer = nextCauseCriticalInstant,
                      i2:Integer = 2,
                      effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance,
                      violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                    }
                  else
                    if iter.wtcCauseLocation > 0 then
                      Tuple{
                        index:Integer = iter.index + 1,
                        flag:Boolean = iter.flag,
                        causeLocation:Integer = iter.causeLocation,
                        midCriticalInstant:Integer = iter.midCriticalInstant,
                        wtcCauseLocation:Integer = iter.wtcCauseLocation,
                        wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                        notWTC:Boolean = iter.notWTC,
                        isWTOC:Boolean = elem.timestamp < iter.wtcMidCriticalInstant,
                        i1:Integer = 1,
                        causeCriticalInstant:Integer = iter.causeCriticalInstant,
                        i2:Integer = 2,
                        effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance,
                        violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                      }
                    else
                      Tuple{
                        index:Integer = iter.index + 1,
                        flag:Boolean = iter.flag,
                        causeLocation:Integer = iter.causeLocation,
                        midCriticalInstant:Integer = iter.midCriticalInstant,
                        wtcCauseLocation:Integer = iter.wtcCauseLocation,
                        wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                        notWTC:Boolean = false,
                        isWTOC:Boolean = elem.timestamp < iter.wtcMidCriticalInstant,
                        i1:Integer = i11,
                        causeCriticalInstant:Integer = nextCauseCriticalInstant,
                        i2:Integer = 2,
                        effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance,
                        violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                      }
                    endif
                  endif
                else
                  if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
                    Tuple{
                      index:Integer = iter.index + 1,
                      flag:Boolean = iter.flag,
                      causeLocation:Integer = iter.causeLocation,
                      midCriticalInstant:Integer = iter.midCriticalInstant,
                      wtcCauseLocation:Integer = iter.wtcCauseLocation,
                      wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                      notWTC:Boolean = iter.notWTC,
                      isWTOC:Boolean = iter.isWTOC,
                      i1:Integer = i11,
                      causeCriticalInstant:Integer = nextCauseCriticalInstant,
                      i2:Integer = 1,
                      effectCriticalInstant:Integer = iter.effectCriticalInstant,
                      violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                    }
                  else
                    if iter.wtcCauseLocation > 0 then
                      Tuple{
                        index:Integer = iter.index + 1,
                        flag:Boolean = iter.flag,
                        causeLocation:Integer = iter.causeLocation,
                        midCriticalInstant:Integer = iter.midCriticalInstant,
                        wtcCauseLocation:Integer = iter.wtcCauseLocation,
                        wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                        notWTC:Boolean = iter.notWTC,
                        isWTOC:Boolean = iter.isWTOC,
                        i1:Integer = 1,
                        causeCriticalInstant:Integer = iter.causeCriticalInstant,
                        i2:Integer = 1,
                        effectCriticalInstant:Integer = iter.effectCriticalInstant,
                        violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                      }
                    else
                      Tuple{
                        index:Integer = iter.index + 1,
                        flag:Boolean = iter.flag,
                        causeLocation:Integer = iter.causeLocation,
                        midCriticalInstant:Integer = iter.midCriticalInstant,
                        wtcCauseLocation:Integer = iter.wtcCauseLocation,
                        wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                        notWTC:Boolean = false,
                        isWTOC:Boolean = iter.isWTOC,
                        i1:Integer = i11,
                        causeCriticalInstant:Integer = nextCauseCriticalInstant,
                        i2:Integer = 1,
                        effectCriticalInstant:Integer = iter.effectCriticalInstant,
                        violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                      }
                    endif
                  endif
                endif
              endif
            endif
          else
            if iter.midCriticalInstant = 0 and e = firstCause then
              if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
                let i22:Integer = iter.i2 + 1 in
                Tuple{
                  index:Integer = iter.index + 1,
                  flag:Boolean = iter.flag,
                  causeLocation:Integer = iter.causeLocation,
                  midCriticalInstant:Integer = iter.midCriticalInstant,
                  wtcCauseLocation:Integer = iter.wtcCauseLocation,
                  wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                  notWTC:Boolean = true,
                  isWTOC:Boolean = iter.isWTOC,
                  i1:Integer = 2,
                  causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
                  i2:Integer = i22,
                  effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                }
              else
                if e = firstEffect then
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.wtcCauseLocation,
                    wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                    notWTC:Boolean = true,
                    isWTOC:Boolean = elem.timestamp < iter.wtcMidCriticalInstant,
                    i1:Integer = 2,
                    causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
                    i2:Integer = 2,
                    effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                  }
                else
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.wtcCauseLocation,
                    wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                    notWTC:Boolean = true,
                    isWTOC:Boolean = iter.isWTOC,
                    i1:Integer = 2,
                    causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
                    i2:Integer = 1,
                    effectCriticalInstant:Integer = iter.effectCriticalInstant,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                  }
                endif
              endif
            else
              if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
                let i22:Integer = iter.i2 + 1 in
                Tuple{
                  index:Integer = iter.index + 1,
                  flag:Boolean = iter.flag,
                  causeLocation:Integer = iter.causeLocation,
                  midCriticalInstant:Integer = iter.midCriticalInstant,
                  wtcCauseLocation:Integer = iter.wtcCauseLocation,
                  wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                  notWTC:Boolean = iter.notWTC,
                  isWTOC:Boolean = iter.isWTOC,
                  i1:Integer = 1,
                  causeCriticalInstant:Integer = iter.causeCriticalInstant,
                  i2:Integer = i22,
                  effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                }
              else
                if e = firstEffect then
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.wtcCauseLocation,
                    wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                    notWTC:Boolean = iter.notWTC,
                    isWTOC:Boolean = elem.timestamp < iter.wtcMidCriticalInstant,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    i2:Integer = 2,
                    effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                  }
                else
                  Tuple{
                    index:Integer = iter.index + 1,
                    flag:Boolean = iter.flag,
                    causeLocation:Integer = iter.causeLocation,
                    midCriticalInstant:Integer = iter.midCriticalInstant,
                    wtcCauseLocation:Integer = iter.wtcCauseLocation,
                    wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                    notWTC:Boolean = iter.notWTC,
                    isWTOC:Boolean = iter.isWTOC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    i2:Integer = 1,
                    effectCriticalInstant:Integer = iter.effectCriticalInstant,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                  }
                endif
              endif
            endif
          endif
        endif
      endif
    else
      iter
    endif
  )
in
result.violations

-- modified on 10/09/2015
def: reportPatternPrecedenceManyManyLeftAtMostMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  lastCauseDistanceType:Integer = causeDistances->last().which,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  lastEffectDistanceType:Integer = effectDistances->last().which,
  result:Tuple(index:Integer, causeLocation:Integer, midCriticalInstant:Integer, wtcCauseLocation:Integer, wtcMidCriticalInstant:Integer, notWTC:Boolean, isWTOC:Boolean, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, causeLocation:Integer, midCriticalInstant:Integer, wtcCauseLocation:Integer, wtcMidCriticalInstant:Integer, notWTC:Boolean, isWTOC:Boolean, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, causeLocation:Integer = 0, midCriticalInstant:Integer = 0, wtcCauseLocation:Integer = 0, wtcMidCriticalInstant:Integer = 0, notWTC:Boolean = true, isWTOC:Boolean = false, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect and self.compare(elem.timestamp, iter.effectCriticalInstant, lastEffectDistanceType) then--the possibility of violation has been checked when e = firstEffect with the condition of elem.timestamp > iter.midCriticalInstant 
      if iter.causeLocation = 0 and iter.wtcCauseLocation = 0 then
        Tuple{
          index:Integer = iter.index + 1,
          causeLocation:Integer = iter.causeLocation,
          midCriticalInstant:Integer = iter.midCriticalInstant,
          wtcCauseLocation:Integer = iter.wtcCauseLocation,
          wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
          notWTC:Boolean = iter.notWTC,
          isWTOC:Boolean = iter.isWTOC,
          i1:Integer = 1,
          causeCriticalInstant:Integer = iter.causeCriticalInstant,
          i2:Integer = 1,
          effectCriticalInstant:Integer = iter.effectCriticalInstant,
          violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}
        }
      else
        if iter.wtcCauseLocation < iter.causeLocation then
          Tuple{
            index:Integer = iter.index + 1,
            causeLocation:Integer = iter.causeLocation,
            midCriticalInstant:Integer = iter.midCriticalInstant,
            wtcCauseLocation:Integer = iter.wtcCauseLocation,
            wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
            notWTC:Boolean = iter.notWTC,
            isWTOC:Boolean = iter.isWTOC,
            i1:Integer = 1,
            causeCriticalInstant:Integer = iter.causeCriticalInstant,
            i2:Integer = 1,
            effectCriticalInstant:Integer = iter.effectCriticalInstant,
            violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
          }
        else
          if iter.isWTOC then
            Tuple{
              index:Integer = iter.index + 1,
              causeLocation:Integer = iter.causeLocation,
              midCriticalInstant:Integer = iter.midCriticalInstant,
              wtcCauseLocation:Integer = iter.wtcCauseLocation,
              wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
              notWTC:Boolean = iter.notWTC,
              isWTOC:Boolean = iter.isWTOC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              i2:Integer = 1,
              effectCriticalInstant:Integer = iter.effectCriticalInstant,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.wtcCauseLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTOC})
            }
          else
            if iter.causeLocation = 0 then
              Tuple{
                index:Integer = iter.index + 1,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = iter.notWTC,
                isWTOC:Boolean = iter.isWTOC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                i2:Integer = 1,
                effectCriticalInstant:Integer = iter.effectCriticalInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.wtcCauseLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC})
              }
            else
              Tuple{
                index:Integer = iter.index + 1,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = iter.notWTC,
                isWTOC:Boolean = iter.isWTOC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                i2:Integer = 1,
                effectCriticalInstant:Integer = iter.effectCriticalInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{iter.causeLocation, iter.wtcCauseLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::LVRI})
              }
            endif
          endif
        endif
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, lastCauseDistanceType) then
            Tuple{
              index:Integer = iter.index + 1,
              causeLocation:Integer = iter.index,
              midCriticalInstant:Integer = elem.timestamp + midDistance,
              wtcCauseLocation:Integer = iter.wtcCauseLocation,
              wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
              notWTC:Boolean = iter.notWTC,
              isWTOC:Boolean = iter.isWTOC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              i2:Integer = 1,
              effectCriticalInstant:Integer = iter.effectCriticalInstant,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          else
            Tuple{
              index:Integer = iter.index + 1,
              causeLocation:Integer = iter.causeLocation,
              midCriticalInstant:Integer = iter.midCriticalInstant,
              wtcCauseLocation:Integer = iter.index,
              wtcMidCriticalInstant:Integer = elem.timestamp + midDistance,
              notWTC:Boolean = iter.notWTC,
              isWTOC:Boolean = iter.isWTOC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              i2:Integer = 1,
              effectCriticalInstant:Integer = iter.effectCriticalInstant,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          endif
        else
          let i11:Integer = iter.i1 + 1, nextCauseCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, flagWTC:Boolean = iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) in
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{
              index:Integer = iter.index + 1,
              causeLocation:Integer = iter.causeLocation,
              midCriticalInstant:Integer = iter.midCriticalInstant,
              wtcCauseLocation:Integer = iter.wtcCauseLocation,
              wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
              notWTC:Boolean = flagWTC,
              isWTOC:Boolean = iter.isWTOC,
              i1:Integer = i11,
              causeCriticalInstant:Integer = nextCauseCriticalInstant,
              i2:Integer = i22,
              effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{
                index:Integer = iter.index + 1,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = iter.notWTC,
                isWTOC:Boolean = iter.wtcMidCriticalInstant > 0 and elem.timestamp > iter.wtcMidCriticalInstant,
                i1:Integer = i11,
                causeCriticalInstant:Integer = nextCauseCriticalInstant,
                i2:Integer = 2,
                effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            else
              Tuple{
                index:Integer = iter.index + 1,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = iter.notWTC,
                isWTOC:Boolean = iter.isWTOC,
                i1:Integer = i11,
                causeCriticalInstant:Integer = nextCauseCriticalInstant,
                i2:Integer = 1,
                effectCriticalInstant:Integer = iter.effectCriticalInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{
              index:Integer = iter.index + 1,
              causeLocation:Integer = iter.causeLocation,
              midCriticalInstant:Integer = iter.midCriticalInstant,
              wtcCauseLocation:Integer = iter.wtcCauseLocation,
              wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
              notWTC:Boolean = true,
              isWTOC:Boolean = iter.isWTOC,
              i1:Integer = 2,
              causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
              i2:Integer = i22,
              effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{
                index:Integer = iter.index + 1,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = true,
                isWTOC:Boolean = iter.wtcMidCriticalInstant > 0 and elem.timestamp > iter.wtcMidCriticalInstant,
                i1:Integer = 2,
                causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
                i2:Integer = 2,
                effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            else
              Tuple{
                index:Integer = iter.index + 1,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = true,
                isWTOC:Boolean = iter.isWTOC,
                i1:Integer = 2,
                causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
                i2:Integer = 1,
                effectCriticalInstant:Integer = iter.effectCriticalInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{
              index:Integer = iter.index + 1,
              causeLocation:Integer = iter.causeLocation,
              midCriticalInstant:Integer = iter.midCriticalInstant,
              wtcCauseLocation:Integer = iter.wtcCauseLocation,
              wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
              notWTC:Boolean = true,
              isWTOC:Boolean = iter.isWTOC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              i2:Integer = i22,
              effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{
                index:Integer = iter.index + 1,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = true,
                isWTOC:Boolean = iter.wtcMidCriticalInstant > 0 and elem.timestamp > iter.wtcMidCriticalInstant,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                i2:Integer = 2,
                effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            else
              Tuple{
                index:Integer = iter.index + 1,
                causeLocation:Integer = iter.causeLocation,
                midCriticalInstant:Integer = iter.midCriticalInstant,
                wtcCauseLocation:Integer = iter.wtcCauseLocation,
                wtcMidCriticalInstant:Integer = iter.wtcMidCriticalInstant,
                notWTC:Boolean = true,
                isWTOC:Boolean = iter.isWTOC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                i2:Integer = 1,
                effectCriticalInstant:Integer = iter.effectCriticalInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            endif
          endif
        endif
      endif
    endif
  )
in
result.violations

-- modified on 10/09/2015
def: reportPatternPrecedenceManyManyLeftExactlyMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  lastCauseDistanceType:Integer = causeDistances->last().which,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value,
  lastEffectDistanceType:Integer = effectDistances->last().which,
  result:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)), notWTC:Boolean, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType))) =
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)), notWTC:Boolean, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer, rollbackInstant:Integer, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)))
    = Tuple{index:Integer = begin, candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = Sequence{}, notWTC:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0, rollbackInstant:Integer = 0, violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{}}
    |
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect and self.compare(elem.timestamp, iter.effectCriticalInstant, lastEffectDistanceType) then
      if iter.candidates->notEmpty() then
        if iter.candidates.midCriticalInstant->excludes(iter.rollbackInstant) then
          let leftViolations:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates->select(midCriticalInstant < iter.rollbackInstant), rightViolations:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates->select(midCriticalInstant > iter.rollbackInstant) in
          if leftViolations->notEmpty() then
            let leftViolation:Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean) = leftViolations->last() in
            if rightViolations->notEmpty() then
              let rightViolation:Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean) = rightViolations->first() in
              if leftViolation.notWTC then
                if rightViolation.notWTC then
                  Tuple{
                    index:Integer = iter.index + 1,
                    candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = rightViolations,
                    notWTC:Boolean = iter.notWTC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    i2:Integer = 1,
                    effectCriticalInstant:Integer = iter.effectCriticalInstant,
                    rollbackInstant:Integer = iter.rollbackInstant,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolation.causeLocation, rightViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
                  }
                else
                  Tuple{
                    index:Integer = iter.index + 1,
                    candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = rightViolations,
                    notWTC:Boolean = iter.notWTC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    i2:Integer = 1,
                    effectCriticalInstant:Integer = iter.effectCriticalInstant,
                    rollbackInstant:Integer = iter.rollbackInstant,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolation.causeLocation, rightViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::LVRI})
                  }
                endif
              else
                if rightViolation.notWTC then
                  Tuple{
                    index:Integer = iter.index + 1,
                    candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = rightViolations,
                    notWTC:Boolean = iter.notWTC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    i2:Integer = 1,
                    effectCriticalInstant:Integer = iter.effectCriticalInstant,
                    rollbackInstant:Integer = iter.rollbackInstant,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolation.causeLocation, rightViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::LIRV})
                  }
                else
                  Tuple{
                    index:Integer = iter.index + 1,
                    candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = rightViolations,
                    notWTC:Boolean = iter.notWTC,
                    i1:Integer = 1,
                    causeCriticalInstant:Integer = iter.causeCriticalInstant,
                    i2:Integer = 1,
                    effectCriticalInstant:Integer = iter.effectCriticalInstant,
                    rollbackInstant:Integer = iter.rollbackInstant,
                    violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolation.causeLocation, rightViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::LIRI})
                  }
                endif
              endif
            else
              if leftViolation.notWTC then
                Tuple{
                  index:Integer = iter.index + 1,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = Sequence{leftViolation},
                  notWTC:Boolean = iter.notWTC,
                  i1:Integer = 1,
                  causeCriticalInstant:Integer = iter.causeCriticalInstant,
                  i2:Integer = 1,
                  effectCriticalInstant:Integer = iter.effectCriticalInstant,
                  rollbackInstant:Integer = iter.rollbackInstant,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
                }
              else
                Tuple{
                  index:Integer = iter.index + 1,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = Sequence{leftViolation},
                  notWTC:Boolean = iter.notWTC,
                  i1:Integer = 1,
                  causeCriticalInstant:Integer = iter.causeCriticalInstant,
                  i2:Integer = 1,
                  effectCriticalInstant:Integer = iter.effectCriticalInstant,
                  rollbackInstant:Integer = iter.rollbackInstant,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{leftViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTOC})
                }
              endif
            endif
          else--if rightViolations->notEmpty() then
            let rightViolation:Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean) = rightViolations->first() in
            if rightViolation.notWTC then
              Tuple{
                index:Integer = iter.index + 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = rightViolations,
                notWTC:Boolean = iter.notWTC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                i2:Integer = 1,
                effectCriticalInstant:Integer = iter.effectCriticalInstant,
                rollbackInstant:Integer = iter.rollbackInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{rightViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTO})
              }
            else
              Tuple{
                index:Integer = iter.index + 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = rightViolations,
                notWTC:Boolean = iter.notWTC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                i2:Integer = 1,
                effectCriticalInstant:Integer = iter.effectCriticalInstant,
                rollbackInstant:Integer = iter.rollbackInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{rightViolation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTOC})
              }
            endif
          endif
        else
          let violation:Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean) = iter.candidates->select(midCriticalInstant = iter.rollbackInstant)->first() in
          if not violation.notWTC then
            Tuple{
              index:Integer = iter.index + 1,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates->reject(midCriticalInstant < iter.rollbackInstant),
              notWTC:Boolean = iter.notWTC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              i2:Integer = 1,
              effectCriticalInstant:Integer = iter.effectCriticalInstant,
              rollbackInstant:Integer = iter.rollbackInstant,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations->append(Tuple{causeLocations:Sequence(Integer) = Sequence{violation.causeLocation}, effectLocations:Sequence(Integer) = Sequence{iter.index}, violationType:ViolationType = ViolationType::WTC})
            }
          else
            Tuple{
              index:Integer = iter.index + 1,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates->reject(midCriticalInstant < iter.rollbackInstant),
              notWTC:Boolean = iter.notWTC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              i2:Integer = 1,
              effectCriticalInstant:Integer = iter.effectCriticalInstant,
              rollbackInstant:Integer = iter.rollbackInstant,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          endif
        endif
      else
        Tuple{
          index:Integer = iter.index + 1,
          candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
          notWTC:Boolean = iter.notWTC,
          i1:Integer = 1,
          causeCriticalInstant:Integer = iter.causeCriticalInstant,
          i2:Integer = 1,
          effectCriticalInstant:Integer = iter.effectCriticalInstant,
          rollbackInstant:Integer = iter.rollbackInstant,
          violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = Sequence{Tuple{causeLocations:Sequence(Integer) = Sequence{}, effectLocations:Sequence(Integer) = iter.violations.effectLocations->append(iter.index), violationType:ViolationType = ViolationType::NSOR}}
        }
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, lastCauseDistanceType) then
            Tuple{
              index:Integer = iter.index + 1,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index, notWTC:Boolean = iter.notWTC}),
              notWTC:Boolean = iter.notWTC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              i2:Integer = 1,
              effectCriticalInstant:Integer = iter.effectCriticalInstant,
              rollbackInstant:Integer = iter.rollbackInstant,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          else
            Tuple{
              index:Integer = iter.index + 1,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates->append(Tuple{midCriticalInstant:Integer = elem.timestamp + midDistance, causeLocation:Integer = iter.index, notWTC:Boolean = false}),
              notWTC:Boolean = iter.notWTC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              i2:Integer = 1,
              effectCriticalInstant:Integer = iter.effectCriticalInstant,
              rollbackInstant:Integer = iter.rollbackInstant,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          endif
        else
          let i11:Integer = iter.i1 + 1, nextCauseCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value in
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
              Tuple{
                index:Integer = iter.index + 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
                notWTC:Boolean = iter.notWTC,
                i1:Integer = i11,
                causeCriticalInstant:Integer = nextCauseCriticalInstant,
                i2:Integer = i22,
                effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value,
                rollbackInstant:Integer = iter.rollbackInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            else
              Tuple{
                index:Integer = iter.index + 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
                notWTC:Boolean = false,
                i1:Integer = i11,
                causeCriticalInstant:Integer = nextCauseCriticalInstant,
                i2:Integer = i22,
                effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value,
                rollbackInstant:Integer = iter.rollbackInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            endif
          else
            if e = firstEffect then
              if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
                Tuple{
                  index:Integer = iter.index + 1,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
                  notWTC:Boolean = iter.notWTC,
                  i1:Integer = i11,
                  causeCriticalInstant:Integer = nextCauseCriticalInstant,
                  i2:Integer = 2,
                  effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance,
                  rollbackInstant:Integer = elem.timestamp,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                }
              else
                Tuple{
                  index:Integer = iter.index + 1,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
                  notWTC:Boolean = false,
                  i1:Integer = i11,
                  causeCriticalInstant:Integer = nextCauseCriticalInstant,
                  i2:Integer = 2,
                  effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance,
                  rollbackInstant:Integer = elem.timestamp,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                }
              endif
            else
              if iter.notWTC and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
                Tuple{
                  index:Integer = iter.index + 1,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
                  notWTC:Boolean = iter.notWTC,
                  i1:Integer = i11,
                  causeCriticalInstant:Integer = nextCauseCriticalInstant,
                  i2:Integer = 1,
                  effectCriticalInstant:Integer = iter.effectCriticalInstant,
                  rollbackInstant:Integer = iter.rollbackInstant,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                }
              else
                Tuple{
                  index:Integer = iter.index + 1,
                  candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
                  notWTC:Boolean = false,
                  i1:Integer = i11,
                  causeCriticalInstant:Integer = nextCauseCriticalInstant,
                  i2:Integer = 1,
                  effectCriticalInstant:Integer = iter.effectCriticalInstant,
                  rollbackInstant:Integer = iter.rollbackInstant,
                  violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
                }
              endif
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{
              index:Integer = iter.index + 1,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
              notWTC:Boolean = true,
              i1:Integer = 2,
              causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
              i2:Integer = i22,
              effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value,
              rollbackInstant:Integer = iter.rollbackInstant,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          else
            if e = firstEffect then
              Tuple{
                index:Integer = iter.index + 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
                notWTC:Boolean = true,
                i1:Integer = 2,
                causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
                i2:Integer = 2,
                effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance,
                rollbackInstant:Integer = elem.timestamp,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            else
              Tuple{
                index:Integer = iter.index + 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
                notWTC:Boolean = true,
                i1:Integer = 2,
                causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance,
                i2:Integer = 1,
                effectCriticalInstant:Integer = iter.effectCriticalInstant,
                rollbackInstant:Integer = iter.rollbackInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{
              index:Integer = iter.index + 1,
              candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
              notWTC:Boolean = iter.notWTC,
              i1:Integer = 1,
              causeCriticalInstant:Integer = iter.causeCriticalInstant,
              i2:Integer = i22,
              effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value,
              rollbackInstant:Integer = iter.rollbackInstant,
              violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
            }
          else
            if e = firstEffect then
              Tuple{
                index:Integer = iter.index + 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
                notWTC:Boolean = iter.notWTC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                i2:Integer = 2,
                effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance,
                rollbackInstant:Integer = elem.timestamp,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            else
              Tuple{
                index:Integer = iter.index + 1,
                candidates:Sequence(Tuple(midCriticalInstant:Integer, causeLocation:Integer, notWTC:Boolean)) = iter.candidates,
                notWTC:Boolean = iter.notWTC,
                i1:Integer = 1,
                causeCriticalInstant:Integer = iter.causeCriticalInstant,
                i2:Integer = 1,
                effectCriticalInstant:Integer = iter.effectCriticalInstant,
                rollbackInstant:Integer = iter.rollbackInstant,
                violations:Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) = iter.violations
              }
            endif
          endif
        endif
      endif
    endif
  )
in
result.violations

--modified on 04/09/2015
def: reportPatternPrecedenceManyManyLeftMidRight(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:tempsy::TimeDistance, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
let midValue:Integer = midDistance.value, midWhich:tempsy::ComparingOperator=midDistance.comparingOperator in
if midWhich = tempsy::ComparingOperator::ATLEAST then
  self.reportPatternPrecedenceManyManyLeftAtLeastMidRight(trace, begin, end, causes, causeDistances, midValue, effects, effectDistances)
else
  if midWhich = tempsy::ComparingOperator::ATMOST then
    self.reportPatternPrecedenceManyManyLeftAtMostMidRight(trace, begin, end, causes, causeDistances, midValue, effects, effectDistances)
  else
    self.reportPatternPrecedenceManyManyLeftExactlyMidRight(trace, begin, end, causes, causeDistances, midValue, effects, effectDistances)
  endif
endif

def: reportPatternPrecedence(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, pattern:tempsy::Pattern): Sequence(Tuple(causeLocations:Sequence(Integer), effectLocations:Sequence(Integer), violationType:ViolationType)) =
--check the satisfiability of the precedence pattern 'cause preceding effect'
--in the first event in the chain 'effect', it may contains time distance to the last event in the chain 'cause'
if begin > end then
  null
else
  let orderPattern:tempsy::OrderPattern = pattern.oclAsType(tempsy::OrderPattern),
      causes:Sequence(String) = orderPattern.block1.event.name,
      causeDistances:Sequence(Tuple(which:Integer, value:Integer)) = self.loadDistances(orderPattern.block1.timeDistance),
      causeSize:Integer = causes->size(),
      effects:Sequence(String) = orderPattern.block2.event.name,
      effectDistances:Sequence(Tuple(which:Integer, value:Integer)) = self.loadDistances(orderPattern.block2.timeDistance),
      effectSize:Integer = effects->size()
  in
  if causeDistances->isEmpty() then
    if effectDistances->isEmpty() then
      if orderPattern.timeDistance->isEmpty() then
        if causeSize = 1 then
          let cause:String = causes->first() in
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.reportPatternPrecedenceOneOnePlain(trace, begin, end, cause, effect)
          else
            self.reportPatternPrecedenceOneManyPlain(trace, begin, end, cause, effects)
          endif
        else
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.reportPatternPrecedenceManyOnePlain(trace, begin, end, causes, effect)
          else
            self.reportPatternPrecedenceManyManyPlain(trace, begin, end, causes, effects)
          endif
        endif
      else
        if causeSize = 1 then
          let cause:String = causes->first() in
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.reportPatternPrecedenceOneOneMid(trace, begin, end, cause, orderPattern.timeDistance, effect)
          else
            self.reportPatternPrecedenceOneManyMid(trace, begin, end, cause, orderPattern.timeDistance, effects)
          endif
        else
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.reportPatternPrecedenceManyOneMid(trace, begin, end, causes, orderPattern.timeDistance, effect)
          else
            self.reportPatternPrecedenceManyManyMid(trace, begin, end, causes, orderPattern.timeDistance, effects)
          endif
        endif
      endif
    else
      if orderPattern.timeDistance->isEmpty() then
        if causeSize = 1 then
          let cause:String = causes->first() in
          self.reportPatternPrecedenceOneManyRight(trace, begin, end, cause, effects, effectDistances)
        else
          self.reportPatternPrecedenceManyManyRight(trace, begin, end, causes, effects, effectDistances)
        endif
      else
        if causeSize = 1 then
          let cause:String = causes->first() in
          self.reportPatternPrecedenceOneManyMidRight(trace, begin, end, cause, orderPattern.timeDistance, effects, effectDistances)
        else
          self.reportPatternPrecedenceManyManyMidRight(trace, begin, end, causes, orderPattern.timeDistance, effects, effectDistances)
        endif
      endif
    endif
  else
    if effectDistances->isEmpty() then
      if orderPattern.timeDistance->isEmpty() then
        if effectSize = 1 then
          let effect:String = effects->first() in
          self.reportPatternPrecedenceManyOneLeft(trace, begin, end, causes, causeDistances, effect)
        else
          self.reportPatternPrecedenceManyManyLeft(trace, begin, end, causes, causeDistances, effects)
        endif
      else
        if effectSize = 1 then
          let effect:String = effects->first() in
          self.reportPatternPrecedenceManyOneLeftMid(trace, begin, end, causes, causeDistances, orderPattern.timeDistance, effect)
        else
          self.reportPatternPrecedenceManyManyLeftMid(trace, begin, end, causes, causeDistances, orderPattern.timeDistance, effects)
        endif
      endif
    else
      if orderPattern.timeDistance->isEmpty() then
        self.reportPatternPrecedenceManyManyLeftRight(trace, begin, end, causes, causeDistances, effects, effectDistances)
      else
        self.reportPatternPrecedenceManyManyLeftMidRight(trace, begin, end, causes, causeDistances, orderPattern.timeDistance, effects, effectDistances)
      endif
    endif
  endif 
endif

def: reportPatternExistence(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, pattern:tempsy::Pattern):Tuple(violations:Sequence(Integer), violationType:ViolationType) =
if begin > end then
  null
else
  let occPattern:tempsy::OccurrencePattern = pattern.oclAsType(tempsy::OccurrencePattern),
    eventName:String = occPattern.event.name,
    occurrences:Sequence(Integer) = trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement; iter:Tuple(index:Integer, locations:Sequence(Integer)) = Tuple{index:Integer = begin, locations:Sequence(Integer) = Sequence{}} |
      if elem.event = eventName then
        Tuple{index:Integer = iter.index + 1, locations:Sequence(Integer) = iter.locations->append(iter.index)}
      else
        Tuple{index:Integer = iter.index + 1, locations:Sequence(Integer) = iter.locations}
      endif
    ).locations
  in
  if occPattern.comparingOperator->notEmpty() then
    let comparingOperator:tempsy::ComparingOperator = occPattern.comparingOperator, n:Integer = occPattern.times in
    if occurrences->size() > n and tempsy::ComparingOperator::ATLEAST <> comparingOperator  then
      Tuple{violations:Sequence(Integer) = occurrences->subSequence(n+1, occurrences->size()), violationType:ViolationType = ViolationType::UNOC}
    else
      if occurrences->size() < n and tempsy::ComparingOperator::ATMOST <> comparingOperator then
        Tuple{violations:Sequence(Integer) = occurrences, violationType:ViolationType = ViolationType::NSOC}
      else
        null
      endif
    endif
  else
    if occurrences->size() = 0 then
      Tuple{violations:Sequence(Integer) = Sequence{}, violationType:ViolationType = ViolationType::NSOC}
    else
      null
    endif
  endif
endif

def: reportPatternAbsence(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, pattern:tempsy::Pattern):Sequence(Integer) =
if begin > end then
  null
else
  let occPattern:tempsy::OccurrencePattern = pattern.oclAsType(tempsy::OccurrencePattern), eventName:String = occPattern.event.name in
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement; iter:Tuple(index:Integer, locations:Sequence(Integer)) = Tuple{index:Integer = begin, locations:Sequence(Integer) = Sequence{}} |
    if elem.event = eventName then
      Tuple{index:Integer = iter.index + 1, locations:Sequence(Integer) = iter.locations->append(iter.index)}
    else
      Tuple{index:Integer = iter.index + 1, locations:Sequence(Integer) = iter.locations}
    endif
  ).locations
endif

def: reportPatternUniversality(trace:OrderedSet(trace::TraceElement), begin:Integer, end:Integer, pattern:tempsy::Pattern):Sequence(Integer) =
--report violation of a universality pattern
if begin > end then
  null
else
  let eventName:String = pattern.oclAsType(tempsy::Universality).event.name in
  trace->subOrderedSet(begin, end)->iterate(elem:trace::TraceElement; iter:Tuple(index:Integer, locations:Sequence(Integer)) = Tuple{index:Integer = begin, locations:Sequence(Integer) = Sequence{}} |
    if elem.event <> eventName then
      Tuple{index:Integer = iter.index + 1, locations:Sequence(Integer) = iter.locations->append(iter.index)}
    else
      Tuple{index:Integer = iter.index + 1, locations:Sequence(Integer) = iter.locations}
    endif
  ).locations
endif

endpackage